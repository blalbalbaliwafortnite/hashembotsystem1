const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
res.send('Hello World!')
res.sendStatus(200);
});

app.listen(port, () => console.log(`app list at http://botsystemhashem1:${port}`));

const { Client, RichEmbed } = require("discord.js");
var { Util } = require("discord.js");
const { prefix, devs, token } = require("./config");
const client = new Client({ disableEveryone: true });
const ytdl = require("ytdl-core");
const canvas = require("canvas");
const convert = require("hh-mm-ss");
const fetchVideoInfo = require("youtube-info");
const botversion = require("./package.json").version;
const simpleytapi = require("simple-youtube-api");
const moment = require("moment");
const fs = require("fs");
const util = require("util");
const gif = require("gif-search");
const ms = require("ms");
const jimp = require("jimp");
const { get } = require("snekfetch");
const guild = require("guild");
const dateFormat = require("dateformat");
const hastebins = require("hastebin-gen");
const pretty = require("pretty-ms");
//const Enmap = require('Enmap')
const { getAnime } = require("request-promise-native");
const usersMap = new Map();
const LIMIT = 5;
const TIME = 7200000;
const DIFF = 3000;

client.login("NzIwNzI5MjAxOTYzMDQwODkw.XwRyFQ.AWiP3JwXlh0h4H4Ue4DjJx7IhyI");
const queue = new Map();
var table = require("table").table;
const Discord = require("discord.js");
//Ù„Ù‚ÙÙ„ Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙŠØ±ÙØ±
//1 = On
//0 = Off
let enabled = 1
client.on('message', message => {
    if (message.content.startsWith(prefix + "cmdon")) {
    if (message.author.id !== '406127752484487168') return message.reply("Ù„ÙŠÙ€Ø³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ©");
        message.reply("**ØªÙ€Ù… ÙØªØ­ Ø¬Ù…ÙŠØ¹ Ø¢ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙŠØ±ÙÙ€Ø±**");
        enabled = 1
    }
    if (message.content.startsWith(prefix + "cmdoff")) {
    if (message.author.id !== '406127752484487168') return message.reply("Ù„ÙŠÙ€Ø³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ©");
        enabled = 0
        message.reply("**ØªÙ€Ù… Ù‚ÙÙ„ Ø¬Ù…ÙŠØ¹ Ø¢ÙˆØ§Ù…Ø± Ø§Ù„Ø³ÙŠØ±ÙÙ€Ø±");
    }
});








client.commands = new Discord.Collection();

fs.readdir("./commands/", (err, files) => {

  if(err) console.log(err);
  let jsfile = files.filter(f => f.split(".").pop() === "js");
  if(jsfile.length <= 0){
    console.log("Couldn't find commands.");
    return;
  }

  jsfile.forEach((f, i) =>{
    let props = require(`./commands/${f}`);
    console.log(`${f} loaded!`);
    client.commands.set(props.help.name, props);
  });
});

client.on("message", async message => {
  if(message.author.bot) return;
  if(message.channel.type === "dm") return;

  let prefix = "!";
  let messageArray = message.content.split(" ");
  let cmd = messageArray[0];
  let args = messageArray.slice(1);
  let commandfile = client.commands.get(cmd.slice(prefix.length));
  if(commandfile) commandfile.run(client,message,args);

});







client.on("ready", () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

const activities_list = [
    "Ø¨ÙˆØª ØªØ¬Ø±ÙŠØ¨ÙŠ / State: ON", 
    "Ø£Ù…Ù€Ù€Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ !help",
    "Ù„Ø§ØªÙ†Ø³ ØªØ³ØªØ®Ø¯Ù… ÙƒÙˆØ¯ HSH", 
    ]; // creates an arraylist containing phrases you want your bot to switch through.

client.on('ready', () => {
    setInterval(() => {
        const index = Math.floor(Math.random() * (activities_list.length - 1) + 1); // generates a random number between 1 and the length of the activities array list (in this case 5).
        client.user.setActivity(activities_list[index]); // sets bot's activities to one of the phrases in the arraylist.
    }, 10000); // Runs this every 10 seconds.
});

//ÙƒÙˆØ¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©
client.on("ready", () => {
  console.log(`Logged in as ${client.user.tag}!`);
  console.log(client.guilds.map(c => `${c.name} : ${c.me.hasPermission(8)}`));
  client.user.setStatus("idle");
});

client.on("message", message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "say") {
    if (!message.member.hasPermission("ADMINISTRATOR"))
      return

    message.channel.send("" + args.join("  "));
    message.delete();
  }
});





client.on('message', msg => {

if(msg.content.startsWith(prefix+"reaction")){
  if(!msg.channel.guild) return;
  for(let n in emojiname){
  var emoji =[msg.guild.emojis.find(r => r.name == emojiname[n])];
  for(let i in emoji){
   msg.react(emoji[i]);
  }
 }
}
});

var emojiname = ["<:pepeOK:719305431767449621> ","<:pepeOK:719305431767449621> "];

//    Add role name
var rolename=["PC","Mobile"];

client.on("messageReactionAdd",(reaction,user)=>{
  if(!user) return;
  if(user.bot)return;
  if(!reaction.message.channel.guild) return;
  for(let n in emojiname){
  if(reaction.emoji.name == emojiname[n]){
    let role = reaction.message.guild.roles.find(r => r.name == rolename[n]);          
    reaction.message.guild.member(user).addRole(role).catch(console.error);
  }
}
});


client.on("messageReactionRemove",(reaction,user)=>{
  if(!user) return;
  if(user.bot)return;
  if(!reaction.message.channel.guild) return;
  for(let n in emojiname){
  if(reaction.emoji.name == emojiname[n]){
    let role = reaction.message.guild.roles.find(r => r.name == rolename[n]);   
    reaction.message.guild.member(user).removeRole(role).catch(console.error);
  }
  }
});








client.on('message', message => {
    if (message.channel.id === '718209175783735378') {
    let messageArray = message.content.split(" ");    
    let args = messageArray.slice(1);
  let countries = args[0]
if (message.content.startsWith(prefix + "corona")) {
    fetch (`https://corona.lmao.ninja/v2/countries/${countries}`)
    .then(res => res.json())
    .then(data => {
        let country = data.country;
       // let flag = data.countryInfo.flag
        let confirmed = data.cases;
        let todayconfirmed = data.todayCases;
        let deaths = data.deaths;
        let todaydeaths = data.todayDeaths;
        let recovered = data.recovered;
        let critical = data.critial;
        let active = data.active;

        const embed = new Discord.RichEmbed()
        .setColor(0x00AE86) 
        .setTimestamp(new Date())
        //.setAuthor("Coronavirus Statistics", flag)
        .addField(`Data for: ${country}`, `Confirmed: (Total: ${confirmed} | Daily: ${todayconfirmed}) \nDeaths: (Total: ${deaths} | Daily: ${todaydeaths}) \n Recoverd: ${recovered} \nCritical: ${critical} \nActive: ${data.active}`)

        message.channel.send(embed);

    })
}}
});




const weather = require("weather-js")

client.on("message", message => {
  // itzZa1D - Codes Team.
    let messageArray = message.content.split(" ");    
    let args = messageArray.slice(1);
  if(enabled){
  if (message.content.startsWith(prefix + "weather")) {
    weather.find({search: args.join(" "), degreeType: "C"}, function(err, result) {
        if(err) message.channel.send(err)

        //If the place entered is invalid
        if(result.length === 0) {
            message.channel.send("**please enter a valid location**")
            return;
        }

        //Variables
        var current = result[0].current //Variable for the current part of the JSON Output
        var location = result[0].location //This is a variable for the location part of the JSON Output

        //Sends weather log in embed
        let embed = new Discord.RichEmbed()
           .setDescription(`**${current.skytext}**`) //How the sky looks like
           .setAuthor(`Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù‚Ø³ ${current.observationpoint}`) //Shows the current location of the weater
           .setThumbnail(current.imageUrl) //Sets thumbnail of the embed
           .setColor(0x00AE86) //Sets the color of the embed
           .addField("Ø§Ù„ÙˆÙ‚Ù€Ù€Øª", `UTC${location.timezone}`, true) //Shows the timezone
           .addField("Ù†ÙˆØ¹ Ø§Ù„Ø¯Ø±Ø¬Ø©", location.degreetype, true) //Shows the degrees in Celcius
           .addField("Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©", `${current.temperature}`, true)
           //.addField("Ø£Ø­Ø³ ÙƒØ£Ù†Ù‡", `${current.feelslike} Ø¯Ø±Ø¬Ø§Øª`, true)
           .addField("Ø±ÙŠØ§Ø­", current.winddisplay, true)
           .addField("Ø±Ø·ÙˆØ¨Ø©", ` ${current.humidity}%`, true)
           .addField("ÙŠÙˆÙ…", `${current.day}`, true)
           .addField("ØªØ§Ø±ÙŠØ®", `${current.date}`, true)

           //Display when it's called
           message.channel.sendEmbed(embed)

    });

  }
  }
  });


var chatal3am = ["ØªÙ„Ø¹Ø¨ Ù…Ø¹ÙŠ","ØªÙ„Ø¹Ø¨ 1v1","1v1","boxfight","arena","trio","eu","middle","Ø§ÙˆØ±ÙˆØ¨ÙŠ","Ù…ÙŠØ¯Ù„ Ø§ÙŠØ³Øª","Ø§Ø±ÙŠÙ†Ø§","Arena","Ø¨ÙˆÙƒØ³ ÙØ§ÙŠØª","Ù†Ø§Ù‚ØµÙ†Ø§ ÙˆØ§Ø­Ø¯","Ù…ÙŠÙ† ÙŠÙ„Ø¹Ø¨ Ø¨ÙˆÙƒØ³ ÙØ§ÙŠØª","Ù…ÙŠÙ† ÙŠÙ„Ø¹Ø¨ Ø§Ø±ÙŠÙ†Ø§","ÙŠØ¨Ø«Ù„ÙŠ","Ø§Ø¨ØºÙŠ ÙˆØ§Ø­Ø¯ ÙŠÙ„Ø¹Ø¨ ØªØ±ÙŠÙˆ","Ù…ÙŠÙ† ÙŠÙ„Ø¹Ø¨ ÙƒØ±ÙŠØ§ØªÙŠÙ","ÙƒØ±ÙŠØ§ØªÙŠÙ","ÙˆØ§Ù† ÙÙŠ ÙˆØ§Ù†Ø§Ø¨ØºÙŠ ÙˆØ§Ø­Ø¯ ÙŠÙ„Ø¹Ø¨","Ø§ÙŠ Ø§Ø­Ø¯ ÙŠÙ„Ø¹Ø¨","Ù…Ø¯Ù„ 4v4", "Ù…ÙŠÙ† ÙŠÙ„Ø¹Ø¨", "Europe", "europe", "middle", "Ù…Ø¯Ù„", "Ù…ÙŠØ¯Ù„","3v3","1v1","2v2","3 v 3", "1 v 1", "2 v 2"];


client.on('message', message => {
    if (message.channel.id === '715066435956899870') {
  if(chatal3am.some(word => message.content.toLowerCase().includes(word))){
    message.delete(1)
    message.channel.sendMessage("Ø¯ÙˆØ± Ù‡Ù†Ø§ Ù…Ùˆ Ù„Ø§Ø²Ù… Ø´Ø§Øª Ø§Ù„Ø¹Ø§Ù…" + message.author)
    message.channel.sendMessage("<#718190508354175158> <#718187163082031177> <#716295431327580250> <#718187464111685695> <#716268576587120730>")
  }
    } else {
    }
});

 const cpuStat = require("cpu-stat");
 const os = require('os')

client.on("message", message => {
  // itzZa1D - Codes Team.
    let messageArray = message.content.split(" ");    
    let args = messageArray.slice(1);
  if(enabled){
  if (message.content.startsWith(prefix + "state")) {
            let { version } = require("discord.js");

            cpuStat.usagePercent(function(err, percent, seconds) {
              if (err) {
                return console.log(err);
              }

             let secs = Math.floor(client.uptime % 60);
             let days = Math.floor((client.uptime % 31536000) / 86400);
             let hours = Math.floor((client.uptime / 3600) % 24);
             let mins = Math.floor((client.uptime / 60) % 60);

              //let duration = moment.duration(bot.uptime).format(" D [days], H [hrs], m [mins], s [secs]");
              let embedStats = new Discord.RichEmbed()
             .setTitle("*** Stats ***")
             .setColor("#00ff00")
             .addField("â€¢ Mem Usage", `${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} / ${(os.totalmem() / 1024 / 1024).toFixed(2)} MB`, true)
             .addField("â€¢ Uptime ", `${hours}h ${mins}m`, true) //`${duration}`, true)
             .addField("â€¢ Users", `${client.users.size.toLocaleString()}`, true)
             .addField("â€¢ Servers", `${client.guilds.size.toLocaleString()}`, true)
             .addField("â€¢ Channels ", `${client.channels.size.toLocaleString()}`, true)
             .addField("â€¢ Discord.js", `v${version}`, true)
            // .addField("â€¢ Node", `${process.version}`, true)
             .addField("â€¢ CPU", `\`\`\`md\n${os.cpus().map(i => `${i.model}`)[0]}\`\`\``)
             .addField("â€¢ CPU usage", `\`${percent.toFixed(2)}%\``,true)
             .addField("â€¢ Arch", `\`${os.arch()}\``,true)
             .addField("â€¢ Platform", `\`\`${os.platform()}\`\``,true)
             .setFooter("OdarBot stats")

             message.channel.send(embedStats)
             })


  }
  }
  });




client.on("message", message => {
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
  if(enabled){
  if (command == "kick") {
    if (message.author.bot) return;
    if (!message.channel.guild)
      return message.reply("** This command only for servers**");

    if (!message.guild.member(message.author).hasPermission("KICK_MEMBERS"))
      return message.reply("**You Don't Have ` KICK_MEMBERS ` Permission**");
    if (!message.guild.member(client.user).hasPermission("KICK_MEMBERS"))
      return message.reply("**I Don't Have ` KICK_MEMBERS ` Permission**");
    let user = message.mentions.users.first();
    let reason = message.content
      .split(" ")
      .slice(2)
      .join(" ");
    if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
    if (!reason) return message.reply("**Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø·Ø±Ø¯**");
    if (!message.guild.member(user).kickable)
      return message.reply(
        "**Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø·Ø±Ø¯ Ø´Ø®Øµ Ø§Ø¹Ù„Ù‰ Ù…Ù† Ø±ØªØ¨ØªÙŠ ÙŠØ±Ø¬Ù‡ Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª Ø±ØªØ¨Ù‡ Ø¹Ø§Ù„ÙŠ**"
      );
    if (
      message.mentions.members.first().highestRole.position >=
      message.member.highestRole.position
    )
      return message.channel.send("Ù…Ø§ ØªÙ‚Ø¯Ø± ØªØ·Ø±Ø¯ Ø´Ø®Øµ Ø±ØªØ¨ØªÙ‡ Ø§Ø¹Ù„Ù‰ Ù…Ù†Ùƒ!");

    message.guild.member(user).kick();

    const kickembed = new Discord.RichEmbed()
      .setAuthor(`KICKED!`, user.displayAvatarURL)
      .setColor("RANDOM")
      .setTimestamp()
      .addField("**User:**", "**[ " + `${user.tag}` + " ]**")
      .addField("**By:**", "**[ " + `${message.author.tag}` + " ]**")
      .addField("**Reason:**", "**[ " + `${reason}` + " ]**");
    message.channel.send({
      embed: kickembed
    });
  }
  }
});





client.on("message", message => {
  if (message.author.bot) return;

  let command = message.content.split(" ")[0];
  if(enabled){
  if (command === prefix + "unmute") {
    if (message.author.bot) return;
    if (!message.member.hasPermission("MANAGE_ROLES")) return message.reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø¨Ø±Ù…Ø´Ù† 'Manage Roles' **").catch(console.error);
    let user = message.mentions.users.first();
    let modlog = client.channels.find(gg => gg.name === "log");
    let muteRole = client.guilds
      .get(message.guild.id)
      .roles.find(gg => gg.name === "Muted");
    if (!muteRole)
      return message
        .reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø±ØªØ¨Ù‡ Ø§Ù„Ù…ÙŠÙˆØª 'Muted' **")
        .catch(console.error);
    if (message.mentions.users.size < 1)
      return message
        .reply("** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ù…Ù†Ø´Ù†Øª Ø´Ø®Øµ Ø§ÙˆÙ„Ø§Ù‹**")
        .catch(console.error);
    const embed = new Discord.RichEmbed()
      .setColor(0x00ae86)
      .setTimestamp()
      .addField("Ø§Ù„Ø£Ø³ØªØ¹Ù…Ø§Ù„:", "Ø§Ø³ÙƒØª/Ø§Ø­ÙƒÙŠ")
      .addField(
        "ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù†:",
        `${user.username}#${user.discriminator} (${user.id})`
      )
      .addField(
        "Ø¨ÙˆØ§Ø³Ø·Ø©:",
        `${message.author.username}#${message.author.discriminator}`
      );

    if (
      !message.guild
        .member(client.user)
        .hasPermission("MANAGE_ROLES_OR_PERMISSIONS")
    )
      return message
        .reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠ Ø¨Ø±Ù…Ø´Ù† Manage Roles **")
        .catch(console.error);

    if (message.guild.member(user).removeRole(muteRole.id)) {
      return message
        .reply("**:white_check_mark: .. ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø§Ù„Ø´Ø®Øµ **")
        .catch(console.error);
    } else {
      message.guild
        .member(user)
        .removeRole(muteRole)
        .then(() => {
          return message
            .reply("**:white_check_mark: .. ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø§Ù„Ø´Ø®Øµ **")
            .catch(console.error);
        });
    }
  }
  }
});

client.on("message", async message => {
if (message.content === '!reboot') {
  if (message.author.id !== '406127752484487168') return;
  message.channel.send('Restarted.')
    client.destroy();
    client.login("NzIwNzI5MjAxOTYzMDQwODkw.XwRyFQ.AWiP3JwXlh0h4H4Ue4DjJx7IhyI");

}
});


/*client.on("message", message => {
  // itzZa1D - Codes Team.
    let messageArray = message.content.split(" ");    
    let args = messageArray.slice(1);
  if (message.content.startsWith(prefix + "fortnite")) {
    let username = args.join(` `)
    if(!username) return message.channel.send("Usage: `!fortnite <username>`")
    let platform = args[1];
const ft = new Fortnite(apikey.fortnite)
    let data = ft.getInfo(username).then(data => {
        let stats = data.lifetimeStats;
        let kills = stats.find(s => s.stat == "kills");
        let wins = stats.find(s => s.stat == "wins");
        let top5s = stats.find(s => s.stat == "top5s");
        let kd = stats.find(s => s.stat == "kd");
        let mPlayed = stats.find(s => s.stat == "matchesPlayed");
        let top3 = stats.find(s => s.stat == "top3");
        let score = stats.find(s => s.stat == "score");
        let tPlayed = stats.find(s => s.stat == "timePlayed");
        let asTime = stats.find(s => s.stat == "avgSurvivalTime");
        let embed = new Discord.RichEmbed()
        .setTitle("Fortnite Stats")
        .setAuthor(data.username)
        .setColor("#00ff00")
        .addField("Kills", kills.value, true)
        .addField("Wins", wins.value, true)
        .addField("KD", kd.value, true)
        .addField("Top 3", top3.value, true)
        .addField("Matches Played", mPlayed.value, true)
        .addField("Time Played", tPlayed.value, true)
        .setFooter(`${data.username}'s score is: ${score.value}`)
        .setTimestamp();
        message.channel.send(embed);
    }).catch(e => {
        console.log(e)
        message.channel.send("Wrong nickname");
    });
}
});*/



//// ÙƒÙˆØ¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®Øµ Ø§Ùˆ Ø§Ù„ÙŠÙˆØ²Ø±
client.on("message", pixelbot => {
  // itzZa1D - Codes Team.
  if(enabled){
  if (pixelbot.content.startsWith(prefix + "user")) {
    // itzZa1D - Codes Team.
    if (pixelbot.author.bot) return;
    if (!pixelbot.guild)
      return pixelbot.reply("**:x: - This Command is only done on Servers**");
    pixelbot.guild.fetchInvites().then(invites => {
      // itzZa1D - Codes Team.
      let personalInvites = invites.filter(
        i => i.inviter.id === pixelbot.author.id
      );
      let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
      var roles = pixelbot.member.roles
        .map(roles => `**__${roles.name}__ |**`)
        .join(` `);
      let pixeluser = new Discord.RichEmbed() // itzZa1D - Codes Team.
        .setColor("#00000")
        .setTitle(" :beginner: :heartpulse:   | Use  r Info") // itzZa1D - Codes Team.
        .setAuthor(pixelbot.author.username, pixelbot.author.avatarURL)
        .addField("**âœ½ Name :**   ", pixelbot.author.username, true)
        .addField("**âœ½ Tag :**   ", pixelbot.author.discriminator, true)
        .addField("**âœ½ ID :** ", pixelbot.author.id, true) // itzZa1D - Codes Team.
        .addField(
          "**âœ½ Joined At :**   ",
          moment(pixelbot.joinedAt).format("D/M/YYYY h:mm a "),
          true
        )
        .addField(
          "**âœ½ Created At :**    ",
          moment(pixelbot.author.createdAt).format("D/M/YYYY h:mm a "),
          true
        )
        .addField("**âœ½ Total invites :**    ", inviteCount, true)
        .setTimestamp(); // itzZa1D - Codes Team.

      pixelbot.channel.sendEmbed(pixeluser).then(c => {}); // itzZa1D - Codes Team.
    });
  }
  }
}); // itzZa1D - Codes Team.



var guilds = [];
var commands = ['me', 'test']; //List of all commands that can be toggled
client.on('*////', () => {
   guilds = client.guilds.map(guild => {  //For each guild create an object of bools based on the commands
      var obj = {};
      commands.forEach(command => obj[command] = true);
      return {
         toggles: obj,
         id: guild.id
      };
   });
});














client.on('messageReactionAdd', (messageReaction, user) => {

    var roleName = messageReaction.emoji.name;
    console.log(user.username + "reacted.");
    var role = messageReaction.message.guild.roles.find(role => role.name.toLowerCase() ===
    roleName.toLowerCase());

    if(role)
    {
        var member = messageReaction.message.guild.members.find(member => member.id === user.id);
        if(member)
        {
            member.addRole(role.id);
            console.log("Success. Added role.");
        }
    }
});

client.on('messageReactionRemove', (messageReaction, user) => {
    var roleName = messageReaction.emoji.name;
    var role = messageReaction.message.guild.roles.find(role => role.name.toLowerCase() ===
    roleName.toLowerCase());

    if(role)
    {
        var member = messageReaction.message.guild.members.find(member => member.id === user.id);
        if(member)
        {
            member.removeRole(role.id);
            console.log("Success. Remove role.");
        }
    }
})










let countChannel = {
  total: "719261514657169468",
  serverID: "713180339820036166"
} 
// Replace ID with the channel ID and server ID (for serverID)
// Follow the instructions: https://youtu.be/UmY0Gsx3KlI?t=44

// We're gonna doing the same thing if member/bot left the server.
client.on("guildMemberAdd", member => {
  if (member.guild.id !== countChannel.serverID) return; // Avoid leaking.

  client.channels.get(countChannel.total).setName(`Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ù€Ù€Ø§Ø¡: ${member.guild.memberCount}`);
})

client.on("guildMemberRemove", member => {
  if (member.guild.id !== countChannel.serverID) return;

  client.channels.get(countChannel.total).setName(`Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ù€Ù€Ø§Ø¡: ${member.guild.memberCount}`);
})






// Ø±ÙŠØ§ÙƒØª ØªÙŠÙƒØª



const embedColor = "#AA8ED6";
const TitleServer = "# killerhashem";


client.on("message", (message) => {
  if (!message.content.startsWith(prefix) || message.author.bot) return;

if (message.content.toLowerCase().startsWith(prefix + `ticket`)) {
    if (!message.channel.name.startsWith(`ğŸ”§-Ø§Ù„Ø¯Ø¹Ù…-Ø§Ù„ÙÙ†ÙŠ`)) return message.channel.send(`**Ù„Ù€Ù€ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù…Ø± Ø§Ù„ØªØ°ÙƒØ±Ø© Ù‡Ù†Ø§ <#719347843353018408> **`);
    const reason = message.content.split(" ").slice(1).join(" ");
    if (!message.guild.roles.exists("name", "ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©")) return message.channel.send(`** Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø¨Ù€ Ø§Ø³Ù… \`ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©\` , Ù„Ø°Ù„Ùƒ Ù„Ù† ÙŠØªÙ… ÙØªØ­ Ø§Ù„ØªØ°ÙƒØ±Ø© .\n Ø¥Ø°Ø§ ÙƒÙ†Øª Ù…Ø³Ø¤ÙˆÙ„Ø§ , Ø§ØµÙ†Ø¹ ÙˆØ§Ø­Ø¯Ø© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù… Ø¨Ø§Ù„Ø¶Ø¨Ø· ÙˆØ£Ø¹Ø·Ù‡Ø§ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ†ÙˆØ§ Ù‚Ø§Ø¯Ø±ÙŠÙ† Ø¹Ù„Ù‰ Ø±Ø¤ÙŠØ© Ø§Ù„ØªØ°Ø§ÙƒØ± **.`);
    if (message.guild.channels.exists("name", "ticket-" + message.author.id)) return message.channel.send(`** Ù„Ø¯ÙŠÙƒ Ø¨Ø§Ù„ÙØ¹Ù„ ØªØ°ÙƒØ±Ø© Ù…ÙØªÙˆØ­Ø© . **`);
    message.guild.createChannel(`ticket-${message.author.username}`, "text").then(c => {
        let role = message.guild.roles.find("name", "ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©");
        let role2 = message.guild.roles.find("name", "@everyone");
        c.overwritePermissions(role, {
            SEND_MESSAGES: true,
            READ_MESSAGES: true
        });
        c.overwritePermissions(role2, {
            SEND_MESSAGES: false,
            READ_MESSAGES: false
        });
        c.overwritePermissions(message.author, {
            SEND_MESSAGES: true,
            READ_MESSAGES: true
        });
        const newEMKAH = new Discord.RichEmbed()
        
        .setColor(embedColor)
        .addField(`Ticket Bot`, `** Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø£Ù†Ø´Ø§Ø¡ ØªØ°ÙƒØ±Ø© , ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø°Ù‡Ø¨ ÙˆÙˆØ¶Ø¹ Ø¨Ù„Ø§Øº Ø§Ùˆ Ù…Ø´ÙƒÙ„ØªÙƒ ÙÙŠ -->** ` + `#${c.name}`)
        .setTimestamp();
      
        message.channel.send({ embed: newEMKAH });
      
        const embed3 = new Discord.RichEmbed()
        .setColor(embedColor)
        .addField(`${message.author.username}!`, `**Ø³Ù€ÙˆÙ ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ Ù‚Ø±ÙŠØ¨Ø§ Ù…Ù† Ù‚Ø¨Ù„ __ ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© __ . ÙŠØ±Ø¬ÙŠ ØªÙˆØ¶ÙŠØ­ Ø³Ø¨Ø¨ Ù„Ø§Ù†Ø´Ø§Ø¦Ùƒ Ø§Ù„ØªØ°ÙƒØ±Ø© ÙˆÙ…Ù† ÙØ¶Ù„Ùƒ Ù‚Ù… Ø¨ÙˆØ¶Ø¹ Ø§ÙƒØ¨Ø± Ù‚Ø¯Ø± Ù…Ù…ÙƒÙ† Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„ **.`)
        .setTimestamp();
        c.send({ embed: embed3 });;
        c.send('@everyone');
    }).catch(console.error);
}
    if (message.content.toLowerCase().startsWith(prefix + `add`)) {
      if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ€Ù€Ùƒ ØµÙ„Ø¢Ø­ÙŠÙ€Ù‡!"'); }
    if (!message.channel.name.startsWith(`ticket-`)) {
    const embed4 = new Discord.RichEmbed()
    .setColor(embedColor)
    .addField(`**TicketsERORR**`, `** Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ Ø§Ù…Ø± Ø®Ø§Ø±Ø¬ Ø±ÙˆÙ… Ø§Ù„ØªØ°ÙƒØ±Ø© .**`)
    message.channel.send({ embed: embed4 });
    return
    }
    let addedmember = message.mentions.members.first();
    if(addedmember < 1) return message.reply("** ÙŠØ±Ø¬Ù‰ Ø°ÙƒØ± Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… **");
    message.channel.overwritePermissions(addedmember, { SEND_MESSAGES : true, VIEW_CHANNEL : true});
    const embed5 = new Discord.RichEmbed()
    .setColor(embedColor)
    .addField(`**Ticket Bot**`, '**' + addedmember + `ØªÙ… Ø§Ø¶Ø§ÙØ© Ù„Ù€ ØªØ°ÙƒØ±ØªÙƒ , ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø²Ø§Ù„Ø© Ø¨Ù€ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù…Ø± --> [${prefix}remove]().**`)
    message.channel.send({ embed: embed5 });

  }

  if (message.content.toLowerCase().startsWith(prefix + `remove`)) {
      if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ€Ù€Ùƒ ØµÙ„Ø¢Ø­ÙŠÙ€Ù‡!"'); }
    if (!message.channel.name.startsWith(`ticket-`)) {
    const embed6 = new Discord.RichEmbed()
    .setColor(embedColor)
    .addField(`**TicketsERORR**`, `** Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ Ø§Ù…Ø± Ø®Ø§Ø±Ø¬ Ø±ÙˆÙ… Ø§Ù„ØªØ°ÙƒØ±Ø© .**`)
    message.channel.send({ embed: embed6 });
    return
    }
    let removedmember = message.mentions.members.first();
    if (removedmember < 1) return message.reply("** ÙŠØ±Ø¬Ù‰ Ø°ÙƒØ± Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… **");
    message.channel.overwritePermissions(removedmember, { SEND_MESSAGES : false, VIEW_CHANNEL : false});
    const embed7 = new Discord.RichEmbed()
    .setColor(embedColor)
    .addField(`Ticket Bot`, '**' + removedmember + ' ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„ØªØ°ÙƒØ±Ø©.**')
    message.channel.send({ embed: embed7 });
  }

if (message.content.toLowerCase().startsWith(prefix + `close`)) {    
    if (!message.channel.name.startsWith(`ticket-`)) return message.channel.send(`** Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ Ø§Ù…Ø± Ø®Ø§Ø±Ø¬ Ø±ÙˆÙ… Ø§Ù„ØªØ°ÙƒØ±Ø© .**`);

    message.channel.send(`**Ù‡Ù„ Ø§Ù†ØªØ§ ÙˆØ§Ø«Ù‚ Ø³ÙˆÙ ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„ØªØ°ÙƒØ±Ø© Ù„Ù„Ø§Ø¨Ø¯ \nÙ„Ù„ØªØ§ÙƒÙŠØ¯ , Ø§ÙƒØªØ¨  \`${prefix}confirm\`. Ø³ÙˆÙ ÙŠÙ†ØªÙ‡ÙŠ Ù‡Ø°Ø§ ÙÙŠ 10 Ø«ÙˆØ§Ù† ÙˆØ³ÙŠØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡ .**`)
    .then((m) => {
      message.channel.awaitMessages(response => response.content === `${prefix}confirm`, {
        max: 1,
        time: 10000,
        errors: ['time'],
      })
      .then((collected) => {
          message.channel.delete();
        })
        .catch(() => {
          m.edit('**Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„ØªØ°Ø§ÙƒØ± ØŒ ÙˆÙ„Ù… ÙŠØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ°ÙƒØ±Ø©.**').then(m2 => {
              m2.delete();
          }, 3000);
        });
    });
}
});












client.on('messageReactionAdd', (reaction, user) => {
    if(reaction.emoji.name === 'ğŸ”’') { // If the emoji name is ticketreact, we will create the ticket channel.
    console.log("dosmth");
    }
}); // ÙƒÙˆØ¯ ØªØ¬Ø±ÙŠØ¨ÙŠ


client.on('message', message => {
    if (message.channel.id === '718209175783735378') {
    if(message.content.split(' ')[0].toLowerCase() == prefix + 'state') {
               if(message.author.bot) return;
        if(!message.channel.guild) return message.reply(' Error : \` Guild Command \`');
    message.channel.send({
        embed: new Discord.RichEmbed()
            .setColor('BLACK')
            .addField('Ping' , [`${Date.now() - message.createdTimestamp}` + 'MS'], true)
            .addField('RAM Usage', `[${(process.memoryUsage().rss / 1048576).toFixed()}MB]`, true)
            .addField('ID' , `[ ${client.user.id} ]` , true)
            .addField('Prefix' , `[ ${prefix} ]` , true)
             .setColor('#36393e')
    })
}
    }
});











////ÙƒÙˆØ¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª
client.on("message", message => {
    if (message.channel.id === '718209175783735378') {
    if(enabled){
  if (message.content === prefix + "bot") {
    const bot = new Discord.RichEmbed()
      .setAuthor(client.user.username, client.user.avatarURL)
      .setColor("#00000")
      .addField(
        "âœ½ **Bot Ping** : ",
        `Â» ${Date.now() - client.createdTimestamp}` + " ms",
        true
      )
      .addField("**Servers** :  ", `Â» ${client.guilds.size}`, true)
      .addField("**Channels** : ", `Â» ${client.channels.size} `, true)
      .addField("**Users** : ", `Â» ${client.users.size} `, true)
      .addField("**Bot Name** :  ", `Â» ${client.user.tag} `, true)
      .addField("**Bot Owner** :  ", `Â» <@406127752484487168>`, true) // ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³Ø§Ø³ÙŠ ØºÙŠØ± Ø§Ù„Ø§ÙŠØ¯ÙŠ Ù„Ø§ÙŠØ¯ÙŠ Ø­Ø³Ø§Ø¨Ùƒ
      .setImage("")
      .setFooter(message.author.username, message.client.avatarURL);
    message.channel.send(bot);
  }
    }
    }
});

client.on("message", async message => {
    if (message.channel.id === '718209175783735378') {
    if(enabled){
  if (message.content.startsWith(prefix + "inf")) {
    //// ÙˆÙ‡ÙˆÙ† Ø§Ù„Ø§Ù…Ø± Ø·Ø¨Ø¹Ø§
    let oi = message.mentions.users.first()
      ? message.mentions.users.first().id
      : message.author.id;
    let Tag = message.mentions.users.first()
      ? message.mentions.users.first().tag
      : message.author.tag;
    let Username = message.mentions.users.first()
      ? message.mentions.users.first().username
      : message.author.username;
    let Avatar = message.mentions.users.first()
      ? message.mentions.users.first().avatarURL
      : message.author.avatarURL;

    message.guild.fetchInvites().then(invs => {
      let member = client.guilds.get(message.guild.id).members.get(oi);
      let personalInvites = invs.filter(i => i.inviter.id === oi);
      let urll = invs.filter(i => i.inviter.id === oi);
      let link = urll.reduce(
        (p, v) =>
          v.url + ` , Total de membros recrutados no convite: ${v.uses}.\n` + p,
        `\nServidor: ${message.guild.name} \n `
      );
      let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
      let inviteCode = personalInvites.reduce((p, v) => v.code);
      let possibleInvites = [["Total de membros recrutados:"]];
      possibleInvites.push([inviteCount, inviteCode]);
      let user = message.mentions.users.first() || message.author;
      let mem = message.guild.member(user);
      let millisJoined = new Date().getTime() - mem.joinedAt.getTime();
      let daysJoined = millisJoined / 1000 / 60 / 60 / 24;
      console.log(inviteCode);
      var inviteInfo = new Discord.RichEmbed()
        .setTitle(`:incoming_envelope: **[INVITE INFO]** ${Username}`)
        .addField(
          "**Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª Ù„Ù„Ø³ÙŠØ±ÙØ±**",
          `[ Ø´Ø®Øµ **${Number(inviteCount)}** ]   `
        )
        .addField(
          "**ØªØ§Ø±ÙŠØ® Ø§Ù†Ø¶Ù…Ø§Ù…Ùƒ Ù„Ø³ÙŠØ±ÙØ±Ù†Ø§ **",
          ` [ Ù…Ù†Ø°  **${daysJoined.toFixed(0)}** ÙŠÙˆÙ… ]   `
        )
        .addField(
          "**Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø°ÙŠ Ø¯Ø®Ù„Øª Ù…Ù†Ù‡**  ",
          `[ **${
            inviteCode &&
            inviteCode.code &&
            inviteCode.code.includes("discord.gg")
              ? inviteCode.code
              : `https://discord.gg/${inviteCode.code || "vHmbKTE"}`
          }** ]   `
        )
        .setImage("")
        .setColor("RANDOM")
        .setTimestamp()
        .setFooter(Tag, Avatar);

      message.channel.send(inviteInfo);
    });
  }
    }
    }
});

client.on("message", message => {
    if (message.channel.id === '718209175783735378') {
  if(enabled){
  if (message.content.split(" ")[0] === prefix + "avt") {
    if (message.author.bot || message.channel.type == "dm") return;
    var args = message.content.split(" ")[1];
    var avt = args || message.author.id;
    client
      .fetchUser(avt)
      .then(user => {
        avt = user;
        let avtEmbed = new Discord.RichEmbed()
          .setColor("#36393e")
          .setAuthor(`${avt.username}'s Avatar`, message.author.avatarURL)
          .setImage(avt.avatarURL)
          .setFooter(`Avatar`, message.client.user.avatarURL);
        message.channel.send(avtEmbed);
      })
      .catch(() => message.channel.send(`ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙˆØ¶Ø¹ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø´Ø®Øµ`));
  } // Julian
  }
    }
}); // Codes - Toxic Codes

const SQLite = require("sqlite"); // SQLpackage
const path = require("path"); // PATHpackage
const invites = {}; // Codes

////ÙƒÙˆØ¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±
client.on("message", message => {
  if(enabled){
  if (message.content.startsWith(prefix + "server")) {
    if (!message.channel.guild)
      return message.channel.send(` | This Command is used only in servers!`);
    const millis = new Date().getTime() - message.guild.createdAt.getTime();
    const now = new Date();
    const verificationLevels = ["None", "Low", "Medium", "Insane", "Extreme"];
    const days = millis / 1000 / 60 / 60 / 24;
    var embed = new Discord.RichEmbed()
      .setAuthor(message.guild.name, message.guild.iconURL)
      .addField(":id:âœ½** Server ID:**", `Â» ${message.guild.id} `, true)
      .addField(
        ":calendar:âœ½** Created On**",
        `Â» ${message.guild.createdAt.toLocaleString()}`,
        true
      )
      .addField(":crown: âœ½**Server Owner**", `**${message.guild.owner}**`, true)
      .addField(
        `âœ½** Members ** [${message.guild.members.size}]`,
        `**${
          message.guild.members.filter(c => c.presence.status !== "offline")
            .size
        }** **Online**`,
        true
      )
      .addField(
        ":speech_balloon:âœ½** Channels **",
        `Â» **${message.guild.channels.filter(m => m.type === "text").size}**` +
          " TexT | VoicE  " +
          `**${message.guild.channels.filter(m => m.type === "voice").size}** `,
        true
      )
      .addField(":earth_africa:âœ½** Region **", ` ${message.guild.region}`, true)
      .setImage("")

      .setColor("#000000");
    message.channel.sendEmbed(embed);
  }
  }
});



//// ÙƒÙˆØ¯ ÙØªØ­ ÙˆØ§ØºÙ„Ø§Ù‚ Ø§Ù„Ø±ÙˆÙ…
client.on("message", message => {
  if(enabled){
  if (message.content === prefix + "closeRom") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply(" Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      })
      .then(() => {
        message.reply("**ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø´Ø§Øª :no_entry: **");
      });
  }
  if (message.content === prefix + "openRom") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: true
      })
      .then(() => {
        message.reply("**ØªÙ… ÙØªØ­ Ø§Ù„Ø´Ø§Øª :white_check_mark:**");
      });
  }
  }
});

client.on("error", err => {
  console.log(err);
});

client.on("messageCreate", async message => {
    if(enabled){
  let args = message.cleanContent.split(" ");
  if (args[0] == `${prefix}roles`) {
    let space = "                         ";
    let roles = message.guild.roles
      .map(r => r)
      .sort((a, b) => b.position - a.position);
    let rr = roles
      .map(
        r =>
          `${r.name +
            space.substring(r.name.length) +
            message.guild.members.filter(m => m.roles.includes(r.id))
              .length} members`
      )
      .join("\n");
    await message.channel.sebd(`\`\`\`${rr}\`\`\``);
  }
    }
});



const FortniteAPI = require('fortnite-api-io');
const fortniteAPI = new FortniteAPI("4f45376e-5ca9f29e-f1785439-aca4d0ba");
let endingDaily = null;
let endingFeatured = null;
const Jimp = require('jimp');






const checkShop = async () => {
    if (endingDaily == null || new Date().getTime() > endingDaily.getTime() || endingFeatured == null || new Date().getTime() > endingFeatured.getTime()) {
        console.log('Sending');
        const data = await fortniteAPI.getDailyShop({ lang: config.lang });
        endingDaily = new Date(data.endingDates.daily);
        endingFeatured = new Date(data.endingDates.featured);
        await generateImage(data);
    }
};

const generateImage = async (shop) => {
    let categories = [
        {
            category: 'featured',
            name: 'Featured',
            items: [],
        },
        {
            category: 'daily',
            name: 'Daily',
            items: [],
        },
        {
            category: 'specialFeatured',
            name: 'Special Featured',
            items: [],
        },
        {
            category: 'specialDaily',
            name: 'Special Daily',
            items: [],
        },
        {
            category: 'community',
            name: 'Community',
            items: [],
        },
    ];

    await categories.forEach((category) => shop[category.category].forEach((item) => category.items.push(item.full_background)));

    const promises = categories.map((category) => generateCategory(category).catch(() => null));
    Promise.all(promises).then(async () => {
        console.log('Created ItemShop');
        const channel = await client.channels.cache.get(config.channelId);
        if (typeof channel != 'undefined')
            await channel.send('ItemShop', {
                files: categories.map((category) => (category.items.length > 0 ? `${__dirname}/tmp/${category.name}.png` : null)).filter((item) => item != null),
            });
    });
};

const generateCategory = ({ name, items }) =>
    new Promise(async (resolve, reject) => {
        if (items.length == 0) return reject('Items is empty');
        const amount = 5;
        const size = 256;
        const rows = Math.ceil(items.length / amount);
        const width = 10 + (size + 10) * amount;
        let height = 120;
        for (let i = 0; i < rows; i++) {
            height += size + 20;
        }

        const img = new Jimp(width, height);

        const font = await Jimp.loadFont(`${__dirname}/Burbank.fnt`);
        await img.print(font, 10, 10, name.toUpperCase());
        const watermark = await img.print(font, width - 150, height - 60, '@NEEROL');

        let y = 60;
        for (let i = 0; i < rows; i++) {
            let x = 10;
            for (let j = i * amount; j < i * amount + amount; j++) {
                if (typeof items[j] == 'undefined') continue;
                const item_img = await Jimp.read(items[j]);
                item_img.resize(size, size).quality(50);
                img.blit(item_img, x, y);
                x += size + 10;
            }
            y += size + 10;
        }
        await img.writeAsync(`${__dirname}/tmp/${name}.png`).catch((err) => console.log(err));
        resolve(img);
    });



















//// ÙƒÙˆØ¯ Ø³Ø­Ø¨ Ø´Ø®Øµ
client.on("message", message => {
  if (!message.channel.guild) return;
  if(enabled){
  if (message.content.startsWith(prefix + "move")) {
    if (message.member.hasPermission("MOVE_MEMBERS")) {
      if (message.mentions.users.size === 0) {
        return message.channel.send("``Use : " + prefix + "move @User``");
      }
      if (message.member.voiceChannel != null) {
        if (message.mentions.members.first().voiceChannel != null) {
          var authorchannel = message.member.voiceChannelID;
          var usermentioned = message.mentions.members.first().id;
          var embed = new Discord.RichEmbed()
            .setTitle("Succes!")
            .setColor("#000000")
            .setDescription(
              `âœ… You Have Moved <@${usermentioned}> To Your Channel `
            );
          var embed = new Discord.RichEmbed()
            .setTitle(`You are Moved in ${message.guild.name} `)
            .setColor("RANDOM")
            .setTitle(`âœ½ **Premium**`)

            .setDescription(
              `**<@${message.author.id}> Moved You To His Channel!\nServer --> ${message.guild.name}**`
            );
          message.guild.members
            .get(usermentioned)
            .setVoiceChannel(authorchannel)
            .then(m => message.channel.send(embed));
          message.guild.members.get(usermentioned).send(embed);
        } else {
          message.channel.send(
            "`You Cant Move" +
              message.mentions.members.first() +
              " `The User Should Be In channel To Move It`"
          );
        }
      } else {
        message.channel.send(
          "**``You Should Be In Room Voice To Move SomeOne``**"
        );
      }
    } else {
      message.react("âŒ");
    }
  }
  }
});

client.on("message", function(message) {
  if (!message.channel.guild) return;
  if (message.author.bot) return;
  if (message.author.id === client.user.id) return;
  if (message.author.equals(client.user)) return;
  if(enabled){
  if (!message.content.startsWith(prefix)) return;

  var args = message.content.substring(prefix.length).split(" ");
  switch (args[0].toLocaleLowerCase()) {
    case "clear":
      message.delete();
      if (!message.channel.guild) return;
      if (message.member.hasPermission("MANAGE_CHANNELS")) {
        if (!args[1]) {
          message.channel.fetchMessages().then(messages => {
            message.channel.bulkDelete(messages);
            var messagesDeleted = messages.array().length;
            message.channel
              .send(
                " " +
                  "**```fix\n" +
                  messagesDeleted +
                  " " +
                  ": Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªÙ… Ù…Ø³Ø­Ù‡Ø§" +
                  "```**"
              )
              .then(m => m.delete(5000));
          });
        } else {
          let messagecount = parseInt(args[1]);
          message.channel
            .fetchMessages({ limit: messagecount })
            .then(messages => message.channel.bulkDelete(messages));
          message.channel
            .send(
              " " +
                "**```fix\n" +
                args[1] +
                " " +
                ": Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªÙ… Ù…Ø³Ø­Ù‡Ø§" +
                "```**"
            )
            .then(m => m.delete(5000));
          message.delete(60000);
        }
      } else {
        var manage = new Discord.RichEmbed()
          .setDescription("You Do Not Have Permission MANAGE_MESSAGES :(")
          .setColor("RANDOM");
        message.channel.sendEmbed(manage);
        return;
      }
  }
  }
});
///ØªØ¹Ø¯ÙŠÙ„ ØºÙŠØ± Ø§Ø³Ø§Ø³ÙŠ
///ÙƒÙˆØ¯ Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø®Ø§Øµ Ù„Ù„Ø£Ø¯Ù…Ù†
client.on("message", message => {
  if(enabled){
  if (message.content == `!Ø§ÙˆØ§Ù…Ø±`) {
    if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ€Ù€Ùƒ ØµÙ„Ø¢Ø­ÙŠÙ€Ù‡!"'); }
          message.author.send(`
\`Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠØ©\` :stars:
\`${prefix}clear\` : Ù„Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª 
\`!ban\` : Ù„Ø­Ø¸Ø± Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±
\`!kick\` : Ù„Ø·Ø±Ø¯ Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±
\`${prefix}openroom\` : Ù„ÙØªØ­ Ø§Ù„Ø´Ø§Øª
\`${prefix}closeroom\` : Ù„Ù‚ÙÙ„ Ø§Ù„Ø´Ø§Øª 
\`${prefix}close\` : Ù„Ù‚ÙÙ„ Ø§Ù„ØªÙŠÙƒØª
\`${prefix}add\` : Ù„Ù€ Ø§Ø¶Ø§ÙØ© Ø´Ø®Øµ Ù„ØªØ°ÙƒØ±Ø©
\`${prefix}remove\` : Ù„Ù€ Ø­Ø°Ù Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„ØªØ°ÙƒØ±Ø©
\`!mute\` : Ù„Ø¥Ø³ÙƒØ§Øª Ø´Ø®Øµ
\`!unmute\` : Ù„Ù€ ÙÙƒ Ø¥Ø³ÙƒØ§Øª Ø´Ø®Øµ
\`${prefix}say\` : Ø§Ù„Ø¨ÙˆØª ÙŠÙƒØ±Ø± ÙƒÙ„Ø§Ù…Ùƒ
\`${prefix}move\` : Ù„Ø³Ø­Ø¨ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù‰ Ø±ÙˆÙˆÙ…Ùƒ
\`${prefix}reply\` : Ù„ØµÙ†Ø¹ Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ
\`${prefix}setLog\` : Ù„ØªØ­Ø¯ÙŠØ¯ Ø±ÙˆÙ… Ø§Ù„Ø³Ø¬Ù„Ø§Øª 
\`${prefix}confirm\` : Ù„Ù‚ÙÙ„ Ø§Ù„ØªØ°ÙƒØ±Ù‡
\`${prefix}setby\` : ØªØ­Ø¯ÙŠØ¯ Ø±ÙˆÙ… Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©
\`${prefix}setMessage\` : Ù„ØªØ­Ø¯ÙŠØ¯ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ 
\`${prefix}setVc\` <channel name> : Ù„ØªØ­Ø¯ÙŠØ¯ Ø±ÙˆÙ… Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ† 
\`${prefix}vc off\` : Ù„Ø¥ØºÙ„Ø§Ù‚ Ø±ÙˆÙ… Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†
\`${prefix}ls\` : Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø¬Ù…ÙŠØ¹ Ø¨ÙˆØªØ§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±
\`${prefix}role\` : Ù„Ø§Ø¹Ø·Ø§Ø¡ Ø´Ø®Øµ Ø±ØªØ¨Ø©
\`${prefix}role all\` : Ù„Ù€ Ø¥Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¬Ù…ÙŠØ¹ Ø±ØªØ¨Ø© Ù…Ø¹ÙŠÙ†Ø©
\`${prefix}role\` : warn Ù„Ù€ Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù†Ø°Ø§Ø± Ù„Ø´Ø®Øµ
 ** ÙŠÙˆØ¬Ø¯ Ø¨Ø¹Ø¶ Ø£Ø®Ø·Ù€Ø§ ÙÙŠ Ø§ÙˆØ§Ù…Ø± Ø§Ù„ØªÙ‚Ø¯ÙŠÙ… ÙŠØªÙ… Ø§ØµÙ„Ø§Ø­Ù‡ Ù‚Ø±ÙŠØ¨Ø§ **
\`\`Ø§ÙˆØ§Ù…Ø± Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…\`\` :pencil: 
\`${prefix}room1\` : Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…Ø§Øª
\`${prefix}room2\` : Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø§Ù„Ù‚Ø¨ÙˆÙ„ ÙˆØ§Ù„Ø±ÙØ¶
\`${prefix}Ù„Ù‚Ø¨ÙˆÙ„ ØªÙ‚Ø¯ÙŠÙ… Ø¹Ø¶Ùˆ : \`Ù‚Ø¨ÙˆÙ„
Ù…Ø«Ø§Ù„: \`\`${prefix}Ù‚Ø¨ÙˆÙ„ @Ù…Ù†Ø´Ù† Ø¹Ø¶Ùˆ \`\`
 ${prefix}Ù„Ø±ÙØ¶ Ø¹Ø¶Ùˆ : Ø±ÙØ¶
Ù…Ø«Ø§Ù„: \`\`${prefix}Ø±ÙØ¶ @Ù…Ù†Ø´Ù† Ø¹Ø¶Ùˆ Ù„Ø³Øª Ù…ØªÙØ§Ø¹Ù„ Ø¨Ø´ÙƒÙ„ ÙƒØ§ÙÙ\`\`
 
\`Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø­Ù…Ø§ÙŠØ©\` :closed_lock_with_key:
                     `);
}
  }
});

////ÙƒÙˆØ¯ Ù‡ÙŠÙ„Ø¨
client.on("message", message => {
  if(enabled){
  if (message.content == `!help`) {
    console.log("help done");
      message.author
        .send(
          `   
\`Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø§Ù…Ø©\` :postbox:
> \`${prefix}bot\` : Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø¨ÙˆØª 
> \`${prefix}user\` : Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù†Ùƒ 
> \`${prefix}avt\` :ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ØµÙˆØ±Øª  Ø§ÙŠ Ø´Ø®Øµ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø§ÙŠØ¯ÙŠ 
> \`${prefix}avatar\` : Ù„Ø¹Ø±Ø¶ ØµÙˆØ±ØªÙƒ Ø£Ùˆ ØµÙˆØ±Ø© Ø§Ù„ÙŠ ØªÙ…Ù†Ø´Ù†Ù‡ 
> \`${prefix}inf\` : Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª Ù„Ù„Ø³ÙŠØ±ÙØ±
> \`${prefix}Ø±Ø§Ø¨Ø·\` : Ø§ÙƒØªØ¨ Ø±Ø§Ø¨Ø· Ø¨Ø§Ù„Ø´Ø§Øª ÙŠØ¬ÙŠÙƒ Ø±Ø§Ø¨Ø· Ø§Ù„Ø³ÙŠØ±ÙØ± Ø®Ø§Øµ
> \`${prefix}weather\` : Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø·Ù‚Ø³ Ø§Ù„Ø¯ÙˆÙ„Ù‡ / Ø§Ù„Ù…Ø¯ÙŠÙ†Ù‡
> \`${prefix}ticket\` : Ù„ÙØªØ­ ØªÙŠÙƒØª
> \`${prefix}state\` : Ù„Ø¹Ù€Ø±Ø¶ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª
> \`${prefix}rank\` : Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø§Ù†Ùƒ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø®Ø§Øµ Ø¨Ùƒ Ø¨Ø³ÙŠØ±ÙØ±
> \`${prefix}leaderboard\` : Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡


\`Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ \` :notes:
**Ø§Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢ÙˆÙ„**
> \`-1loop\` : Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡ ØªØªÙƒØ±Ø±
> \`-1leave\` : Ù„Ù€ Ø§Ø®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©
> \`-1pause\` : Ù„ØªÙˆÙ‚ÙŠÙ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-1play\` : Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§ØºÙ†ÙŠØ©
> \`-1queue\` : [q] Ù„Ù€ Ø¹Ø±Ø¶ Ø§ØºØ§Ù†ÙŠ Ø§Ù„Ù„ÙŠØ³Øª Ø­Ø§Ù„ÙŠØ§ -> Ø§Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ù…Ø±
> \`-1remove\` : Ù„Ù…Ø³Ø­ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-1resume\` : Ù„Ø§ÙƒÙ…Ø§Ù„ Ø§Ù„Ø§ØºÙ†ÙŠØ©
> \`-1skip\` : Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-1skipall\` : Ù„ØªØ®Ø·ÙŠ ÙƒÙ„ Ø§ØºØ§Ù†ÙŠ
> \`-1skipto\` : Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡ Ø¹Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø±Ù‚Ù… Ø§ØºÙ†ÙŠÙ‡ Ù…ÙˆØ¬ÙˆØ¯  Ø¨ Ù„ÙŠØ³Øª
**Ø§Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø«Ù€Ø§Ù†ÙŠ**
> \`-2loop\` : Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡ ØªØªÙƒØ±Ø±
> \`-2leave\` : Ù„Ù€ Ø§Ø®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©
> \`-2pause\` : Ù„ØªÙˆÙ‚ÙŠÙ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-2play\` : Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§ØºÙ†ÙŠØ©
> \`-2queue\` : [q] Ù„Ù€ Ø¹Ø±Ø¶ Ø§ØºØ§Ù†ÙŠ Ø§Ù„Ù„ÙŠØ³Øª Ø­Ø§Ù„ÙŠØ§ -> Ø§Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ù…Ø±
> \`-2remove\` : Ù„Ù…Ø³Ø­ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-2resume\` : Ù„Ø§ÙƒÙ…Ø§Ù„ Ø§Ù„Ø§ØºÙ†ÙŠØ©
> \`-2skip\` : Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡
> \`-2skipall\` : Ù„ØªØ®Ø·ÙŠ ÙƒÙ„ Ø§ØºØ§Ù†ÙŠ
> \`-2skipto\` : Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø§ØºÙ†ÙŠÙ‡ Ø¹Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø±Ù‚Ù… Ø§ØºÙ†ÙŠÙ‡ Ù…ÙˆØ¬ÙˆØ¯  Ø¨ Ù„ÙŠØ³Øª
`)

  };
  }
});



/// ÙƒÙˆØ¯ ØªØ¹ÙŠÙ† Ø§Ù„Ù„ÙˆÙ‚
const log = JSON.parse(fs.readFileSync("./log.json", "utf8"));

client.on("message", message => {
  if (!message.channel.guild) return;
  let room = message.content.split(" ").slice(1);
  let findroom = message.guild.channels.find(r => r.name == room);
  if(enabled){
  if (message.content.startsWith(prefix + "setLog")) {
    if (!message.channel.guild)
      return message.reply("**This Command Only For Servers**");
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(
        "**Sorry But You Dont Have Permission** `MANAGE_GUILD`"
      );
    if (!room) return message.channel.send("Please Type The Channel Name");
    if (!findroom)
      return message.channel.send("Please Type The Log Channel Name");
    let embed = new Discord.RichEmbed()
      .setTitle("**Done The Log Code Has Been Setup**")
      .addField("Channel:", `${room}`)
      .addField("Requested By:", `${message.author}`)
      .setThumbnail(message.author.avatarURL)
      .setFooter(`${client.user.username}`);
    message.channel.sendEmbed(embed);
    log[message.guild.id] = {
      channel: room,
      onoff: "On"
    };
    fs.writeFile("./log.json", JSON.stringify(log), err => {
      if (err) console.error(err);
    });
  }
  }
});

client.on("message", message => {
  if(enabled){
  if (message.content.startsWith(prefix + "toggleLog")) {
    if (!message.channel.guild)
      return message.reply("**This Command Only For Servers**");
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(
        "**Sorry But You Dont Have Permission** `MANAGE_GUILD`"
      );
    if (!log[message.guild.id])
      log[message.guild.id] = {
        onoff: "Off"
      };
    if (log[message.guild.id].onoff === "Off")
      return [
        message.channel.send(`**The log Is __ğğ__ !**`),
        (log[message.guild.id].onoff = "On")
      ];
    if (log[message.guild.id].onoff === "On")
      return [
        message.channel.send(`**The log Is __ğğ…ğ…__ !**`),
        (log[message.guild.id].onoff = "Off")
      ];
    fs.writeFile("./log.json", JSON.stringify(log), err => {
      if (err)
        console.error(err).catch(err => {
          console.error(err);
        });
    });
  }
  }
});








client.on("message", message => {
  if (message.author.codes) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
  if(enabled){
  if (command == "ban") {
    if (message.author.bot) return;
    if (!message.channel.guild)
      return message.reply("** This command only for servers**");

    if (!message.guild.member(message.author).hasPermission("BAN_MEMBERS"))
      return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡**");
    if (!message.guild.member(client.user).hasPermission("BAN_MEMBERS"))
      return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
    let user = message.mentions.users.first();

    if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
    if (
      message.mentions.members.first().highestRole.position >=
      message.member.highestRole.position
    )
      return message.channel.send("Ù…Ø§ ØªÙ‚Ø¯Ø± ØªØ¨Ù†Ø¯ Ø´Ø®Øµ Ø±ØªØ¨ØªÙ‡ Ø§Ø¹Ù„Ù‰ Ù…Ù†Ùƒ!");
    if (!message.guild.member(user).bannable)
      return message.reply(
        "**ÙŠØ¬Ø¨ Ø§Ù† ØªÙƒÙˆÙ† Ø±ØªØ¨Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ø¹Ù„ÙŠ Ù…Ù† Ø±ØªØ¨Ù‡ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ¨Ù†ÙŠØ¯Ø©**"
      );

    message.guild.member(user).ban(7, user);

    message.channel.send(
      `**:white_check_mark: ${user.tag} banned from the server ! :airplane: **  `
    );
  }
  }
});

client.on("messageDelete", message => {
  if (message.author.bot) return;
  if (message.channel.type === "dm") return;
  if (!message.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES"))
    return;
  if (!log[message.guild.id])
    log[message.guild.id] = {
      onoff2: "Off"
    };
  if (log[message.guild.id].onoff2 === "Off") return;
  var logChannel = client.channels.get('719300006263259147');
  if (!logChannel) return;

  let messageDelete = new Discord.RichEmbed()
    .setTitle("**[MESSAGE DELETE]**")
    .setColor("RED")
    .setThumbnail(message.author.avatarURL)
    .setDescription(
      `**\n**:wastebasket: Successfully \`\`DELETE\`\` **MESSAGE** In ${message.channel}\n\n**Channel:** \`\`${message.channel.name}\`\` (ID: ${message.channel.id})\n**Message ID:** ${message.id}\n**Sent By:** <@${message.author.id}> (ID: ${message.author.id})\n**Message:**\n\`\`\`${message}\`\`\``
    )
    .setTimestamp()
    .setFooter(message.guild.name, message.guild.iconURL);

  logChannel.send(messageDelete);
});


client.on("messageUpdate", (oldMessage, newMessage) => {
  if (oldMessage.author.bot) return;
  if (!oldMessage.channel.type === "dm") return;
  if (!oldMessage.guild.member(client.user).hasPermission("EMBED_LINKS"))
    return;
  if (!oldMessage.guild.member(client.user).hasPermission("MANAGE_MESSAGES"))
    return;
  if (!log[oldMessage.guild.id])
    log[oldMessage.guild.id] = {
      onoff: "Off"
    };
  if (log[oldMessage.guild.id].onoff === "Off") return;
  var logChannel = client.channels.get('719300006263259147');
  if (!logChannel) return;

  if (oldMessage.content.startsWith("https://")) return;

  let messageUpdate = new Discord.RichEmbed()
    .setTitle("**[MESSAGE EDIT]**")
    .setThumbnail(oldMessage.author.avatarURL)
    .setColor("BLUE")
    .setDescription(
      `**\n**:wrench: Successfully \`\`EDIT\`\` **MESSAGE** In ${oldMessage.channel}\n\n**Channel:** \`\`${oldMessage.channel.name}\`\` (ID: ${oldMessage.channel.id})\n**Message ID:** ${oldMessage.id}\n**Sent By:** <@${oldMessage.author.id}> (ID: ${oldMessage.author.id})\n\n**Old Message:**\`\`\`${oldMessage}\`\`\`\n**New Message:**\`\`\`${newMessage}\`\`\``
    )
    .setTimestamp()
    .setFooter(oldMessage.guild.name, oldMessage.guild.iconURL);

  logChannel.send(messageUpdate);
});

client.on("roleCreate", role => {
  if (!role.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!role.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG")) return;
  if (!log[role.guild.id])
    log[role.guild.id] = {
      onoff: "Off"
    };
  if (log[role.guild.id].onoff === "Off") return;
  var logChannel = client.channels.get('719298415410020383');
  if (!logChannel) return;

  role.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    let roleCreate = new Discord.RichEmbed()
      .setTitle("**[ROLE CREATE]**")
      .setThumbnail(userAvatar)
      .setDescription(
        `**\n**:white_check_mark: Successfully \`\`CREATE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setColor("GREEN")
      .setTimestamp()
      .setFooter(role.guild.name, role.guild.iconURL);

    logChannel.send(roleCreate);
  });
});
client.on("roleDelete", role => {
  if (!role.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!role.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG")) return;
  if (!log[role.guild.id])
    log[role.guild.id] = {
      onoff: "Off"
    };
  if (log[role.guild.id].onoff === "Off") return;
  var logChannel = client.channels.get('719298415410020383');
  if (!logChannel) return;

  role.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    let roleDelete = new Discord.RichEmbed()
      .setTitle("**[ROLE DELETE]**")
      .setThumbnail(userAvatar)
      .setDescription(
        `**\n**:white_check_mark: Successfully \`\`DELETE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setColor("RED")
      .setTimestamp()
      .setFooter(role.guild.name, role.guild.iconURL);

    logChannel.send(roleDelete);
  });
});
client.on("roleUpdate", (oldRole, newRole) => {
  if (!oldRole.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!oldRole.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG"))
    return;
  if (!log[oldRole.guild.id])
    log[oldRole.guild.id] = {
      onoff: "Off"
    };
  if (log[oldRole.guild.id].onoff === "Off") return;
  var logChannel = client.channels.get('719298415410020383');
  if (!logChannel) return;

  oldRole.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    if (oldRole.name !== newRole.name) {
      if (log[oldRole.guild.id].onoff === "Off") return;
      let roleUpdateName = new Discord.RichEmbed()
        .setTitle("**[ROLE NAME UPDATE]**")
        .setThumbnail(userAvatar)
        .setColor("BLUE")
        .setDescription(
          `**\n**:white_check_mark: Successfully \`\`EDITED\`\` Role Name.\n\n**Old Name:** \`\`${oldRole.name}\`\`\n**New Name:** \`\`${newRole.name}\`\`\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(oldRole.guild.name, oldRole.guild.iconURL);

      logChannel.send(roleUpdateName);
    }
    if (oldRole.hexColor !== newRole.hexColor) {
      if (oldRole.hexColor === "#000000") {
        var oldColor = "`Default`";
      } else {
        var oldColor = oldRole.hexColor;
      }
      if (newRole.hexColor === "#000000") {
        var newColor = "`Default`";
      } else {
        var newColor = newRole.hexColor;
      }
      if (log[oldRole.guild.id].onoff === "Off") return;
      let roleUpdateColor = new Discord.RichEmbed()
        .setTitle("**[ROLE COLOR UPDATE]**")
        .setThumbnail(userAvatar)
        .setColor("BLUE")
        .setDescription(
          `**\n**:white_check_mark: Successfully \`\`EDITED\`\` **${oldRole.name}** Role Color.\n\n**Old Color:** ${oldColor}\n**New Color:** ${newColor}\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(oldRole.guild.name, oldRole.guild.iconURL);

      logChannel.send(roleUpdateColor);
    }
  });
});

client.on("channelCreate", channel => {
  if (!channel.guild) return;
  if (!channel.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!channel.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG"))
    return;
  if (!log[channel.guild.id])
    log[channel.guild.id] = {
      onoff: "Off"
    };
  if (log[channel.guild.id].onoff === "Off") return;
  var logChannel = channel.guild.channels.find(
    c => c.name === `${log[channel.guild.id].channel}`
  );
  if (!logChannel) return;

  if (channel.type === "text") {
    var roomType = "Text";
  } else if (channel.type === "voice") {
    var roomType = "Voice";
  } else if (channel.type === "category") {
    var roomType = "Category";
  }

  channel.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    let channelCreate = new Discord.RichEmbed()
      .setTitle("**[CHANNEL CREATE]**")
      .setThumbnail(userAvatar)
      .setDescription(
        `**\n**:white_check_mark: Successfully \`\`CREATE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setColor("GREEN")
      .setTimestamp()
      .setFooter(channel.guild.name, channel.guild.iconURL);

    logChannel.send(channelCreate);
  });
});
client.on("channelDelete", channel => {
  if (!channel.guild) return;
  if (!channel.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!channel.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG"))
    return;
  if (!log[channel.guild.id])
    log[channel.guild.id] = {
      onoff: "Off"
    };
  if (log[channel.guild.id].onoff === "Off") return;
  var logChannel = channel.guild.channels.find(
    c => c.name === `${log[channel.guild.id].channel}`
  );
  if (!logChannel) return;

  if (channel.type === "text") {
    var roomType = "Text";
  } else if (channel.type === "voice") {
    var roomType = "Voice";
  } else if (channel.type === "category") {
    var roomType = "Category";
  }

  channel.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    let channelDelete = new Discord.RichEmbed()
      .setTitle("**[CHANNEL DELETE]**")
      .setThumbnail(userAvatar)
      .setDescription(
        `**\n**:white_check_mark: Successfully \`\`DELETE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setColor("RED")
      .setTimestamp()
      .setFooter(channel.guild.name, channel.guild.iconURL);

    logChannel.send(channelDelete);
  });
});
client.on("channelUpdate", (oldChannel, newChannel) => {
  if (!oldChannel.guild) return;
  if (!log[oldChannel.guild.id])
    log[oldChannel.guild.id] = {
      onoff: "Off"
    };
  if (log[oldChannel.guild.id].onoff === "Off") return;
  var logChannel = oldChannel.guild.channels.find(
    c => c.name === `${log[oldChannel.guild.id].channel}`
  );
  if (!logChannel) return;

  if (oldChannel.type === "text") {
    var channelType = "Text";
  } else if (oldChannel.type === "voice") {
    var channelType = "Voice";
  } else if (oldChannel.type === "category") {
    var channelType = "Category";
  }

  oldChannel.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    if (oldChannel.name !== newChannel.name) {
      let newName = new Discord.RichEmbed()
        .setTitle("**[CHANNEL EDIT]**")
        .setThumbnail(userAvatar)
        .setColor("BLUE")
        .setDescription(
          `**\n**:wrench: Successfully Edited **${channelType}** Channel Name\n\n**Old Name:** \`\`${oldChannel.name}\`\`\n**New Name:** \`\`${newChannel.name}\`\`\n**Channel ID:** ${oldChannel.id}\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL);

      logChannel.send(newName);
    }
    if (oldChannel.topic !== newChannel.topic) {
      if (log[oldChannel.guild.id].onoff === "Off") return;
      let newTopic = new Discord.RichEmbed()
        .setTitle("**[CHANNEL EDIT]**")
        .setThumbnail(userAvatar)
        .setColor("BLUE")
        .setDescription(
          `**\n**:wrench: Successfully Edited **${channelType}** Channel Topic\n\n**Old Topic:**\n\`\`\`${oldChannel.topic ||
            "NULL"}\`\`\`\n**New Topic:**\n\`\`\`${newChannel.topic ||
            "NULL"}\`\`\`\n**Channel:** ${oldChannel} (ID: ${
            oldChannel.id
          })\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL);

      logChannel.send(newTopic);
    }
  });
});

client.on("guildBanAdd", (guild, user) => {
  if (!guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!guild.member(client.user).hasPermission("VIEW_AUDIT_LOG")) return;
  if (!log[guild.id])
    log[guild.id] = {
      onoff: "Off"
    };
  if (log[guild.id].onoff === "Off") return;
  var logChannel = client.channels.get('715748542777524244');
  if (!logChannel) return;

  guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    if (userID === client.user.id) return;

    let banInfo = new Discord.RichEmbed()
      .setTitle("**[BANNED]**")
      .setThumbnail(userAvatar)
      .setColor("DARK_RED")
      .setDescription(
        `**\n**:airplane: Successfully \`\`BANNED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setTimestamp()
      .setFooter(guild.name, guild.iconURL);

    logChannel.send(banInfo);
  });
});
client.on("guildBanRemove", (guild, user) => {
  if (!guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!guild.member(client.user).hasPermission("VIEW_AUDIT_LOG")) return;
  if (!log[guild.id])
    log[guild.id] = {
      onoff: "Off"
    };
  if (log[guild.id].onoff === "Off") return;
  var logChannel = guild.channels.find(
    c => c.name === `${log[guild.id].channel}`
  );
  if (!logChannel) return;

  guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;

    if (userID === client.user.id) return;

    let unBanInfo = new Discord.RichEmbed()
      .setTitle("**[UNBANNED]**")
      .setThumbnail(userAvatar)
      .setColor("GREEN")
      .setDescription(
        `**\n**:unlock: Successfully \`\`UNBANNED\`\` **${user.username}** From the server\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`
      )
      .setTimestamp()
      .setFooter(guild.name, guild.iconURL);

    logChannel.send(unBanInfo);
  });
});

client.on("guildMemberUpdate", (oldMember, newMember) => {
  if (!oldMember.guild) return;
  if (!log[oldMember.guild.id])
    log[oldMember.guild.id] = {
      onoff: "Off"
    };
  if (log[oldMember.guild.id].onoff === "Off") return;
  var logChannel = oldMember.guild.channels.find(
    c => c.name === `${log[(oldMember, newMember.guild.id)].channel}`
  );
  if (!logChannel) return;

  oldMember.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userAvatar = logs.entries.first().executor.avatarURL;
    var userTag = logs.entries.first().executor.tag;

    if (oldMember.nickname !== newMember.nickname) {
      if (oldMember.nickname === null) {
        var oldNM = "`Ø§Ø³Ù…Ù‡ Ø§Ù„Ø§ØµÙ„ÙŠ`";
      } else {
        var oldNM = oldMember.nickname;
      }
      if (newMember.nickname === null) {
        var newNM = "`Ø§Ø³Ù…Ù‡ Ø§Ù„Ø§ØµÙ„ÙŠ`";
      } else {
        var newNM = newMember.nickname;
      }

      let updateNickname = new Discord.RichEmbed()
        .setTitle("**[UPDATE MEMBER NICKNAME]**")
        .setThumbnail(userAvatar)
        .setColor("BLUE")
        .setDescription(
          `**\n**:spy: Successfully \`\`CHANGE\`\` Member Nickname.\n\n**User:** ${oldMember} (ID: ${oldMember.id})\n**Old Nickname:** ${oldNM}\n**New Nickname:** ${newNM}\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(oldMember.guild.name, oldMember.guild.iconURL);

      logChannel.send(updateNickname);
    }
    if (oldMember.roles.size < newMember.roles.size) {
      let role = newMember.roles
        .filter(r => !oldMember.roles.has(r.id))
        .first();
      if (!log[oldMember.guild.id])
        log[oldMember.guild.id] = {
          onoff: "Off"
        };
      if (log[oldMember.guild.id].onoff === "Off") return;
      let roleAdded = new Discord.RichEmbed()
        .setTitle("**[ADDED ROLE TO MEMBER]**")
        .setThumbnail(oldMember.guild.iconURL)
        .setColor("GREEN")
        .setDescription(
          `**\n**:white_check_mark: Successfully \`\`ADDED\`\` Role to **${oldMember.user.username}**\n\n**User:** <@${oldMember.id}> (ID: ${oldMember.user.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(roleAdded);
    }
    if (oldMember.roles.size > newMember.roles.size) {
      let role = oldMember.roles
        .filter(r => !newMember.roles.has(r.id))
        .first();
      if (!log[oldMember.guild.id])
        log[oldMember.guild.id] = {
          onoff: "Off"
        };
      if (log[(oldMember, newMember.guild.id)].onoff === "Off") return;
      let roleRemoved = new Discord.RichEmbed()
        .setTitle("**[REMOVED ROLE FROM MEMBER]**")
        .setThumbnail(oldMember.guild.iconURL)
        .setColor("RED")
        .setDescription(
          `**\n**:negative_squared_cross_mark: Successfully \`\`REMOVED\`\` Role from **${oldMember.user.username}**\n\n**User:** <@${oldMember.user.id}> (ID: ${oldMember.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(roleRemoved);
    }
  });
  if (oldMember.guild.owner.id !== newMember.guild.owner.id) {
    if (!log[oldMember.guild.id])
      log[oldMember.guild.id] = {
        onoff: "Off"
      };
    if (log[(oldMember, newMember.guild.id)].onoff === "Off") return;
    let newOwner = new Discord.RichEmbed()
      .setTitle("**[UPDATE GUILD OWNER]**")
      .setThumbnail(oldMember.guild.iconURL)
      .setColor("GREEN")
      .setDescription(
        `**\n**:white_check_mark: Successfully \`\`TRANSFER\`\` The Owner Ship.\n\n**Old Owner:** <@${oldMember.user.id}> (ID: ${oldMember.user.id})\n**New Owner:** <@${newMember.user.id}> (ID: ${newMember.user.id})`
      )
      .setTimestamp()
      .setFooter(oldMember.guild.name, oldMember.guild.iconURL);

    logChannel.send(newOwner);
  }
});

client.on("voiceStateUpdate", (voiceOld, voiceNew) => {
  if (!voiceOld.guild.member(client.user).hasPermission("EMBED_LINKS")) return;
  if (!voiceOld.guild.member(client.user).hasPermission("VIEW_AUDIT_LOG"))
    return;
  if (!log[voiceOld.guild.id])
    log[voiceOld.guild.id] = {
      onoff: "Off"
    };
  if (log[(voiceOld, voiceOld.guild.id)].onoff === "Off") return;
  var logChannel = voiceOld.guild.channels.find(
    c => c.name === `${log[(voiceOld, voiceNew.guild.id)].channel}`
  );
  if (!logChannel) return;

  voiceOld.guild.fetchAuditLogs().then(logs => {
    var userID = logs.entries.first().executor.id;
    var userTag = logs.entries.first().executor.tag;
    var userAvatar = logs.entries.first().executor.avatarURL;

    if (voiceOld.serverMute === false && voiceNew.serverMute === true) {
      let serverMutev = new Discord.RichEmbed()
        .setTitle("**[VOICE MUTE]**")
        .setThumbnail(
          "https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png"
        )
        .setColor("RED")
        .setDescription(
          `**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(serverMutev);
    }
    if (voiceOld.serverMute === true && voiceNew.serverMute === false) {
      if (!log[voiceOld.guild.id])
        log[voiceOld.guild.id] = {
          onoff: "Off"
        };
      if (log[(voiceOld, voiceOld.guild.id)].onoff === "Off") return;
      let serverUnmutev = new Discord.RichEmbed()
        .setTitle("**[VOICE UNMUTE]**")
        .setThumbnail(
          "https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png"
        )
        .setColor("GREEN")
        .setDescription(
          `**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(serverUnmutev);
    }
    if (voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
      if (!log[voiceOld.guild.id])
        log[voiceOld.guild.id] = {
          onoff: "Off"
        };
      if (log[(voiceOld, voiceOld.guild.id)].onoff === "Off") return;
      let serverDeafv = new Discord.RichEmbed()
        .setTitle("**[VOICE DEAF]**")
        .setThumbnail(
          "https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png"
        )
        .setColor("RED")
        .setDescription(
          `**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(serverDeafv);
    }
    if (voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
      if (!log[voiceOld.guild.id])
        log[voiceOld.guild.id] = {
          onoff: "Off"
        };
      if (log[(voiceOld, voiceOld.guild.id)].onoff === "Off") return;
      let serverUndeafv = new Discord.RichEmbed()
        .setTitle("**[VOICE UNDEAF]**")
        .setThumbnail(
          "https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png"
        )
        .setColor("GREEN")
        .setDescription(
          `**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`
        )
        .setTimestamp()
        .setFooter(userTag, userAvatar);

      logChannel.send(serverUndeafv);
    }
  });

  if (
    voiceOld.voiceChannelID !== voiceNew.voiceChannelID &&
    voiceNew.voiceChannel &&
    voiceOld.voiceChannel != null
  ) {
    if (!log[voiceOld.guild.id])
      log[voiceOld.guild.id] = {
        onoff: "Off"
      };
    if (log[(voiceOld, voiceOld.guild.id)].onoff === "Off") return;
    let voiceLeave = new Discord.RichEmbed()
      .setTitle("**[CHANGED VOICE ROOM]**")
      .setColor("GREEN")
      .setThumbnail(voiceOld.user.avatarURL)
      .setDescription(
        `**\n**:repeat: Successfully \`\`CHANGED\`\` The Voice Channel.\n\n**From:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**To:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`
      )
      .setTimestamp()
      .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL);

    logChannel.send(voiceLeave);
  }
});

///////////////////

///ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³Ø§Ø³ÙŠ
/// ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
client.on("ready", () => {
  console.log(`Logged in as ${client.user.tag}!`);

});



client.on("message", message => {
  if(enabled){
  if (message.content === "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…") {
    message.channel.send(":heart: ÙˆØ¹Ù„ÙŠÙƒÙ… Ø§Ù„Ø³Ù„Ø§Ù… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡ :heart:");
  }
  }
  });
client.on("message", message => {
  if(enabled){
  if (message.content === "Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…") {
    message.channel.send(":heart: ÙˆØ¹Ù„ÙŠÙƒÙ… Ø§Ù„Ø³Ù„Ø§Ù… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡ :heart:");
  }
  }
  });

client.on("message", message => {
  if(enabled){
  if (message.content === "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡") {
    message.channel.send(":heart: ÙˆØ¹Ù„ÙŠÙƒÙ… Ø§Ù„Ø³Ù„Ø§Ù… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡ :heart:");
  }
  }
});

client.on("message", message => {
  if(enabled){
  if (message.content === "Ø¨Ø§Ùƒ") {
    message.channel.send("ÙˆÙ„ÙƒÙ… Ù…Ù† Ø¬Ø¯ÙŠØ¯ ÙŠ Ø¨Ø·Ù€Ù€Ù„ :heart:");
  }
  }
});

///ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³Ø§Ø³ÙŠ
///Ù„Ùˆ ØªØ¨ÙŠ ØªØ¹Ø·Ù„ ÙƒÙˆØ¯ Ø¨Ø¯ÙˆÙ† Ø­Ø°ÙÙ‡ Ø­Ø· Ù‡Ø°ÙŠ Ø§Ù„Ø±Ù…ÙˆØ²

/*
///test
*/

///// ÙƒÙˆØ¯ Ø®Ø±ÙˆØ¬ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡

/////ÙƒÙˆØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø¨ÙˆØª Ø§Ùˆ Ø§Ù„Ø¨ÙŠÙ†Ù‚
client.on("message", message => {
  if (!message.channel.guild) return;
    if (message.channel.id === '718209175783735378') {
  if(enabled){
  if (message.content.startsWith(prefix + "ping")) {
    if (message.author.bot) return;
    if (!message.channel.guild) return;
    var Bping = `${Math.round(client.ping)}`;

    const E1ping = new Discord.RichEmbed()
      .setTitle("Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€")
      .addField(
        `**BOT Ping Is** :__${Bping}ğŸ“¶__`,
        "Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€"
      )
      .setFooter(`Requested by | ${message.author.tag}`)
      .setColor("RANDOM");
    message.channel.send(E1ping);
  }
  }
    }
});

let anti = JSON.parse(fs.readFileSync("./antigrefff.json", "UTF8"));
let config = JSON.parse(fs.readFileSync("./server.json", "UTF8"));
client.on("message", message => {
  if (!message.channel.guild) return;
  let user = anti[message.guild.id + message.author.id];
  let num = message.content
    .split(" ")
    .slice(2)
    .join(" ");
  if (!anti[message.guild.id + message.author.id])
    anti[message.guild.id + message.author.id] = {
      actions: 0
    };
  if (!config[message.guild.id])
    config[message.guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
    if(enabled){
  if (message.content.startsWith(prefix + "settings")) {
    if (message.author.id !== message.guild.owner.user.id)
      return message.channel.send(
        "**:closed_lock_with_key: Ù„Ø£Ø³Ø¨Ø§Ø¨ ØªØªØ¹Ù„Ù‚ Ø¨Ø§Ù„Ø­Ù…Ø§ÙŠØ© ØªÙ… Ø­ØµØ± Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø­Ù…Ø§ÙŠØ© ÙÙ‚Ø· Ù„Ù„Ø£ÙˆÙ†Ø±**"
      );
    if (message.content.startsWith(prefix + "settings limitsban")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].banLimit = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].banLimit} **`
      );
    }
    if (message.content.startsWith(prefix + "settings limitskick")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].kickLimits = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].kickLimits}**`
      );
    }
    if (message.content.startsWith(prefix + "settings limitsroleD")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].roleDelLimit = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].roleDelLimit}**`
      );
    }
    if (message.content.startsWith(prefix + "settings limitsroleC")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].roleCrLimits = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].roleCrLimits}**`
      );
    }
    if (message.content.startsWith(prefix + "settings limitschannelD")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].chaDelLimit = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].chaDelLimit}**`
      );
    }
    if (message.content.startsWith(prefix + "settings limitschannelC")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].chaCrLimit = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].chaCrLimit}**`
      );
    }
    if (message.content.startsWith(prefix + "settings limitstime")) {
      if (!num) return message.channel.send("**:1234: | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
      if (isNaN(num)) return message.channel.send("**:1234: | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
      config[message.guild.id].time = num;
      message.channel.send(
        `**:lock: | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].time}**`
      );
    }
  }
  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
    }
});
client.on("channelDelete", async channel => {
  const entry1 = await channel.guild
    .fetchAuditLogs({
      type: "CHANNEL_DELETE"
    })
    .then(audit => audit.entries.first());
  console.log(entry1.executor.username);
  const entry = entry1.executor;
  if (!config[channel.guild.id])
    config[channel.guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
  if (!anti[channel.guild.id + entry.id]) {
    anti[channel.guild.id + entry.id] = {
      actions: 1
    };
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
  } else {
    anti[channel.guild.id + entry.id].actions = Math.floor(
      anti[channel.guild.id + entry.id].actions + 1
    );
    console.log("TETS");
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
    if (
      anti[channel.guild.id + entry.id].actions >=
      config[channel.guild.id].chaDelLimit
    ) {
      channel.guild.members
        .get(entry.id)
        .ban()
      anti[channel.guild.id + entry.id].actions = "0";
      fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
      fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
    }
  }

  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
});


client.on("roleDelete", async channel => {
  const entry1 = await channel.guild
    .fetchAuditLogs({
      type: "ROLE_DELETE"
    })
    .then(audit => audit.entries.first());
  console.log(entry1.executor.username);
  const entry = entry1.executor;
  if (!config[channel.guild.id])
    config[channel.guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
  if (!anti[channel.guild.id + entry.id]) {
    anti[channel.guild.id + entry.id] = {
      actions: 1
    };
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
  } else {
    anti[channel.guild.id + entry.id].actions = Math.floor(
      anti[channel.guild.id + entry.id].actions + 1
    );
    console.log("TETS");
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
    if (
      anti[channel.guild.id + entry.id].actions >=
      config[channel.guild.id].roleDelLimit
    ) {
      channel.guild.members
        .get(entry.id)
        .ban()
        .catch(e =>
          channel.guild.owner.send(
            `**â‡ | ${entry.username} Ù‚Ø§Ù… Ø¨Ù…Ø³Ø­ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ø±ØªØ¨ **`
          )
        );
      anti[channel.guild.id + entry.id].actions = "0";
      fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
      fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
    }
  }

  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
});

client.on("roleCreate", async channel => {
  const entry1 = await channel.guild
    .fetchAuditLogs({
      type: "ROLE_CREATE"
    })
    .then(audit => audit.entries.first());
  console.log(entry1.executor.username);
  const entry = entry1.executor;
  if (!config[channel.guild.id])
    config[channel.guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
  if (!anti[channel.guild.id + entry.id]) {
    anti[channel.guild.id + entry.id] = {
      actions: 1
    };
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
  } else {
    anti[channel.guild.id + entry.id].actions = Math.floor(
      anti[channel.guild.id + entry.id].actions + 1
    );
    console.log("TETS");
    setTimeout(() => {
      anti[channel.guild.id + entry.id].actions = "0";
    }, config[channel.guild.id].time * 1000);
    if (
      anti[channel.guild.id + entry.id].actions >=
      config[channel.guild.id].roleCrLimits
    ) {
      channel.guild.members
        .get(entry.id)
        .ban()
        .catch(e =>
          channel.guild.owner.send(
            `**â‡ | ${entry.username} Ù‚Ø§Ù… Ø¨Ø£Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ø±ØªØ¨ **`
          )
        );
      anti[channel.guild.id + entry.id].actions = "0";
      fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
      fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
    }
  }

  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
});

client.on("guildBanAdd", async (guild, user) => {
  const entry1 = await guild
    .fetchAuditLogs({
      type: "MEMBER_BAN_ADD"
    })
    .then(audit => audit.entries.first());
  console.log("ban: " + entry1.executor.username);
  const entry = entry1.executor;
  if (!config[guild.id])
    config[guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
  if (!anti[guild.id + entry.id]) {
    anti[guild.id + entry.id] = {
      actions: 1
    };
    setTimeout(() => {
      anti[guild.id + entry.id].actions = 0;
    }, config[guild.id].time * 1000);
  } else {
    anti[guild.id + entry.id].actions = Math.floor(
      anti[guild.id + entry.id].actions + 1
    );
    setTimeout(() => {
      anti[guild.id + entry.id].actions = 0;
    }, config[guild.id].time * 1000);
    if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
      guild.members
        .get(entry.id)
        .ban()
        .catch(e =>
          guild.owner.send(`**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`)
        );
      anti[guild.id + entry.id].actions = 0;
      fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
      fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
    }
  }

  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
});

client.on("guildKickAdd", async (guild, user) => {
  const entry1 = await guild
    .fetchAuditLogs({
      type: "MEMBER_KICK"
    })
    .then(audit => audit.entries.first());
  console.log(entry1.executor.username);
  const entry = entry1.executor;
  if (!config[guild.id])
    config[guild.id] = {
      banLimit: 3,
      chaDelLimit: 3,
      chaCrLimit: 3,
      roleDelLimit: 3,
      kickLimits: 3,
      roleCrLimits: 3,
      time: 30
    };
  if (!anti[guild.id + entry.id]) {
    anti[guild.id + entry.id] = {
      actions: 1
    };
    setTimeout(() => {
      anti[guild.id + entry.id].actions = 0;
    }, config[guild.id].time * 1000);
  } else {
    anti[guild.id + entry.id].actions = Math.floor(
      anti[guild.id + entry.id].actions + 1
    );
    console.log("TETS");
    setTimeout(() => {
      anti[guild.id + entry.id].actions = 0;
    }, config[guild.id].time * 1000);
    if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
      guild.members
        .get(entry.id)
        .ban()
        .catch(e =>
          guild.owner.send(`**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`)
        );
      anti[guild.id + entry.id].actions = 0;
      fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
      fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
        e
      ) {
        if (e) throw e;
      });
    }
  }

  fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
    if (e) throw e;
  });
  fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(e) {
    if (e) throw e;
  });
});

client.on("guildMemberRemove", async member => {
  const entry1 = await member.guild
    .fetchAuditLogs()
    .then(audit => audit.entries.first());
  if (entry1.action === "MEMBER_KICK") {
    const entry2 = await member.guild
      .fetchAuditLogs({
        type: "MEMBER_KICK"
      })
      .then(audit => audit.entries.first());
    const entry = entry2.executor;
    if (!config[member.guild.id])
      config[guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        chaCrLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3,
        time: 30
      };
    if (!anti[member.guild.id + entry.id]) {
      anti[member.guild.id + entry.id] = {
        actions: 1
      };
      setTimeout(() => {
        anti[member.guild.id + entry.id].actions = 0;
      }, config[member.guild.id].time * 1000);
    } else {
      anti[member.guild.id + entry.id].actions = Math.floor(
        anti[member.guild.id + entry.id].actions + 1
      );
      console.log("TETS");
      setTimeout(() => {
        anti[member.guild.id + entry.id].actions = 0;
      }, config[member.guild.id].time * 1000 || 30000);
      if (
        anti[member.guild.id + entry.id].actions >=
        config[member.guild.id].kickLimits
      ) {
        member.guild.members
          .get(entry.id)
          .ban()
          .catch(e =>
            member.owner.send(
              `**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`
            )
          );
        anti[member.guild.id + entry.id].actions = 0;
        fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(
          e
        ) {
          if (e) throw e;
        });
        fs.writeFile(
          "./antigreff.json",
          JSON.stringify(anti, null, 2),
          function(e) {
            if (e) throw e;
          }
        );
      }
    }

    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function(e) {
      if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function(
      e
    ) {
      if (e) throw e;
    });
  }
});

client.on("message", async message => {
  const moment = require("moment"); //npm i moment
  const ms = require("ms"); //npm i ms
  // var prefix = '' //Bot Prefix !
  var time = moment().format("Do MMMM YYYY , hh:mm");
  var room;
  var title;
  var duration;
  var currentTime = new Date(),
    hours = currentTime.getHours() + 3,
    minutes = currentTime.getMinutes(),
    done = currentTime.getMinutes() + duration,
    seconds = currentTime.getSeconds();
  if (minutes < 10) {
    minutes = "0" + minutes;
  }
  var suffix = "AM";
  if (hours >= 12) {
    suffix = "PM";
    hours = hours - 12;
  }
  if (hours == 0) {
    hours = 12;
  }

  var filter = m => m.author.id === message.author.id;
    if(enabled){
  if (message.content.startsWith(prefix + "gcreate")) {
    let embed1 = new Discord.RichEmbed()
      .setColor()
      .setDescription("Missing the following permission `MANAGE_GUILD`");

    let embed2 = new Discord.RichEmbed()
      .setColor()
      .setDescription("Please send the `room` name without mentioning it");

    let embed3 = new Discord.RichEmbed()
      .setColor()
      .setDescription("Wrong room name");

    let embed4 = new Discord.RichEmbed()
      .setColor()
      .setDescription("Please send the `time`");

    let embed5 = new Discord.RichEmbed()
      .setColor()
      .setDescription(
        "Wrong time format\nExample of time format: 1s / 1m / 1h / 1d / 1w"
      );

    let embed6 = new Discord.RichEmbed()
      .setColor()
      .setDescription("Please send the `gift`");

    if (!message.guild.member(message.author).hasPermission("MANAGE_GUILD"))
      return message.channel.send(embed1);
    message.channel.send(embed2).then(msg => {
      message.channel
        .awaitMessages(filter, {
          max: 1,
          time: 20000,
          errors: ["time"]
        })
        .then(collected => {
          let room = message.guild.channels.find(
            gg => gg.name === collected.first().content
          );
          if (!room) return message.channel.send(embed3);
          room = collected.first().content;
          collected.first().delete();
          msg.edit(embed4).then(msg => {
            message.channel
              .awaitMessages(filter, {
                max: 1,
                time: 20000,
                errors: ["time"]
              })
              .then(collected => {
                if (!collected.first().content.match(/[1-60][s,m,h,d,w]/g))
                  return message.channel.send(embed5);
                duration = collected.first().content;
                collected.first().delete();
                msg.edit(embed6).then(msg => {
                  message.channel
                    .awaitMessages(filter, {
                      max: 1,
                      time: 20000,
                      errors: ["time"]
                    })
                    .then(collected => {
                      title = collected.first().content;
                      collected.first().delete();
                      msg.delete();
                      message.delete();
                      try {
                        let giveEmbed = new Discord.RichEmbed()
                          .setColor()
                          .setTitle(`${title}`)
                          .setDescription(
                            `React With ğŸ‰ To Enter! \nTime remaining : ${duration} \n **Created at :** ${hours}:${minutes}:${seconds} ${suffix}`
                          );
                        //.setFooter(message.author.username, message.author.avatarURL);
                        message.guild.channels
                          .find(gg => gg.name === room)
                          .send(" :tada: **Giveaway** :tada:", {
                            embed: giveEmbed
                          })
                          .then(m => {
                            let re = m.react("ğŸ‰");
                            setTimeout(() => {
                              let users = m.reactions.get("ğŸ‰").users;
                              let list = users
                                .array()
                                .filter(
                                  u => (u.id !== m.author.id) !== client.user.id
                                );
                              let gFilter =
                                list[
                                  Math.floor(Math.random() * list.length) + 1
                                ];
                              if (gFilter === undefined) {
                                let endEmbed = new Discord.RichEmbed()
                                  .setColor()
                                  .setTitle(title)
                                  .setDescription(
                                    `Winners : no enough number of reaction so there is no winner`
                                  )
                                  .setFooter("Ended at :")
                                  .setTimestamp();
                                m.edit("** ğŸ‰ GIVEAWAY ENDED ğŸ‰**", {
                                  embed: endEmbed
                                });
                              } else {
                                let endEmbed = new Discord.RichEmbed()
                                  .setColor()
                                  .setTitle(title)
                                  .setDescription(`Winners : ${gFilter}`)
                                  .setFooter("Ended at :")
                                  .setTimestamp();
                                m.edit("** ğŸ‰ GIVEAWAY ENDED ğŸ‰**", {
                                  embed: endEmbed
                                });
                              }
                              if (gFilter === undefined) {
                                // message.guild.channels.find("name" , room).send("No enough number of reactions")
                              } else {
                                message.guild.channels
                                  .find(gg => gg.name === room)
                                  .send(
                                    `**Congratulations ${gFilter}! You won The \`${title}\`**`
                                  );
                              }
                            }, ms(duration));
                          });
                      } catch (e) {
                        message.channel.send(
                          `:heavy_multiplication_x:| **i Don't Have Prem**`
                        );
                        console.log(e);
                      }
                    });
                });
              });
          });
        });
    });
  }
    }
});

///ÙƒÙˆØ¯ Ø­Ø°Ù Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
/// ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³Ø§Ø³ÙŠ Ø­Ø°Ù Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯
/// ØªÙ… Ø­Ø°Ù Ø§Ù„ÙƒÙˆØ¯ Ù„Ø§Ù†Ù‡ ÙŠØ³Ø¨Ø¨ Ù…Ø´Ø§ÙƒÙ„ Ù…Ø«Ù„Ø§ ÙŠØ­Ø°Ù ÙƒÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø­ØªÙ‰ Ù…Ù† Ø§Ù„Ø§Ø¯Ø§Ø±Ø© ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙˆØª Ø¨Ø±ÙˆØ¨ÙˆØª ÙÙŠ Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„Ø±ÙˆØ§Ø¨Ø·

const replyMSG = JSON.parse(fs.readFileSync("./replyMSG.json", "utf8"));

function saveReplay() {
  fs.writeFile("./replyMSG.json", JSON.stringify(replyMSG), function(err) {
    if (err) throw err;
  });
}

/////ÙƒÙˆØ¯ ØµÙ†Ø¹ Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ
client.on("message", async message => {
    if(enabled){
  if (message.content.startsWith(prefix + "reply")) {
    if (message.author.bot || message.channel.type == "dm") return undefined;
    if (!message.member.hasPermission("ADMINISTRATOR")) return;
    if (!replyMSG[message.author.id])
      replyMSG[message.author.id] = {
        contentmessage: "none",
        replayMessage: "none"
      };
    saveReplay();
    let contmessage;

    let filter = m => m.author.id === message.author.id;
    message.channel.send(" |** Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ø§Ù†...** ").then(msg => {
      message.channel
        .awaitMessages(filter, {
          //R.I.P Royal Bot!
          maxMatches: 1,
          time: 12000,
          errors: ["time"]
        })

        .then(collected => {
          contmessage = collected.first().content;
          msg.edit(":scroll: | Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø¯ Ø§Ù„Ø§Ù†... :pencil2: ");

          message.channel
            .awaitMessages(filter, {
              maxMatches: 1,
              time: 12000,
              errors: ["time"]
            })

            .then(async collectedd => {
              replyMSG[message.author.id] = {
                contentmessage: contmessage,
                replayMessage: collectedd.first().content
              };
              saveReplay();
              var embed1 = new Discord.RichEmbed()
                .setTitle(`Done The Autoreply Setup`)
                .setThumbnail(message.author.avatarURL)
                .setColor("GRAY")
                .setDescription(
                  `
                    Message:
                    ${contmessage}
                    Reply:
                    ${collectedd.first().content}`
                );
              let steve = await client.fetchUser("359541019836022784");
              embed1.setFooter(
                `Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ`,
                steve ? steve.displayAvatarURL : message.author.displayAvatarURL
              );
              msg.edit("  |** ØªÙ… Ø§Ù„Ø§Ø¹Ø¯Ø§Ø¯ Ø¨Ù†Ø¬Ø§Ø­...**");

              message.channel.send(embed1);
            });
        });
    });
  }
    }
});

client.on("message", message => {
  if (
    !replyMSG[message.author.id] ||
    !replyMSG[message.author.id].contentmessage ||
    !replyMSG[message.author.id].replayMessage
  )
    return;
  let messagecontent = replyMSG[message.author.id].contentmessage;
  let reply = replyMSG[message.author.id].replayMessage;
  if (message.content == messagecontent) {
    if (messagecontent == "none" || reply == "none") return undefined;
    message.channel.send(`\`#\` ${reply}`);
  }
});


////ÙƒÙˆØ¯ Ø±Ø§Ø¨Ø·
////ØªØ¹Ø¯ÙŠÙ„ ØºÙŠØ± Ø§Ø³Ø§Ø³ÙŠ

client.on("message", message => {
  if(enabled){
  if (message.content.split(" ")[0] === prefix + "Ø±Ø§Ø¨Ø·") {
    message.channel
      .createInvite({
        thing: true,
        maxUses: 5,
        maxAge: 86400
      })
      .then(invite => message.author.send(invite.url));
    const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(
        "** ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Øµ ØŒ Ø§Ø°Ø§ Ù„Ù… ÙŠØµÙ„Ùƒ Ø§ÙØªØ­ Ø§Ù„Ø®Ø§Øµ  **"
      )
      .setAuthor(client.user.username, client.user.avatarURL)
      .setAuthor(client.user.username, client.user.avatarURL)
      .setFooter("Ø·Ù„Ø¨ Ø¨ÙˆØ§Ø³Ø·Ø©: " + message.author.tag);

    message.channel.sendEmbed(embed).then(message => {
      message.delete(10000);
    });
    const Embed11 = new Discord.RichEmbed().setColor("RANDOM")
      .setDescription(`** Ù…Ø¯Ø© Ø§Ù„Ø±Ø§Ø¨Ø· : ÙŠÙˆÙ… 
 Ø¹Ø¯Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª Ø§Ù„Ø±Ø§Ø¨Ø· : 5 **`);

    message.author.sendEmbed(Embed11);
  }
  }
});

////Ù„Ø§ÙŠØ­ØªØ§Ø¬ ØªØ¹Ø¯ÙŠÙ„
////ÙƒÙˆØ¯ Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†

const vojson = JSON.parse(fs.readFileSync("./tkdim.json", "utf8")); //Ù…Ù„Ù ØªØ®Ø²ÙŠÙ† Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†
client.on("message", message => {
  if(enabled){
  if (message.content.startsWith(prefix + "setVc")) {
    let channel = message.content
      .split(" ")
      .slice(1)
      .join(" ");
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(
        "**ADMINISTRATOR Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© :rolling_eyes: ** "
      );
    let channelfind = message.guild.channels.find(c => c.name == channel);
    if (!channel)
      return message.channel.send(
        "Please Type The Voice Channel Name Example: " +
          `${prefix}setVc <Channel name>`
      );
    if (!channelfind)
      return message.channel.send(`I can't find this channel \`${channel}\``);
    vojson[message.guild.id] = {
      stats: "enable",
      chid: channelfind.id,
      guild: message.guild.id
    };
    channelfind.setName(
      `Voice Online : ${message.guild.members.filter(m => m.voiceChannel).size}` ///ØªØ¹Ø¯ÙŠÙ„ ØºÙŠØ± Ø§Ø³Ø§Ø³ÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³Ù… Ø±ÙˆÙ… Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†
    );
    message.channel.send("**Done The Voice Online  Is Turned On**");
  }
  if (message.content.startsWith(prefix + "vc off")) {
    // Ø§ÙŠÙ‚Ø§Ù Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(
        "ADMINISTRATOR Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© :rolling_eyes:"
      );

    message.guild.channels
      .find(gg => gg.name === vojson[message.guild.id].chid)
      .delete();
    vojson[message.guild.id] = {
      stats: "disable",
      chid: "undefined",
      guild: message.guild.id
    };
    message.channel.send("**Done The Voice Online Is Turned Off**");
  }
  fs.writeFile("./vojson.json", JSON.stringify(vojson), err => {
    if (err) console.error(err);
  });
  }
});

client.on("ready", () => {
  console.log("hi");
});

client.on("voiceStateUpdate", (oldMember, newMember) => {
  if (!vojson[oldMember.guild.id])
    vojson[oldMember.guild.id] = {
      stats: "disable",
      chid: "undefined",
      guild: "undefined"
    };
  if (vojson[oldMember.guild.id].stats === "enable") {
    let ch = vojson[oldMember.guild.id].chid;
    let channel = oldMember.guild.channels.get(ch);
    if (!channel) return;
    let guildid = vojson[oldMember.guild.id].guild;
    channel.setName(
      `Voice Online : ${
        oldMember.guild.members.filter(m => m.voiceChannel).size
      }` ///ØªØ¹Ø¯ÙŠÙ„ ØºÙŠØ± Ø§Ø³Ø§Ø³ÙŠ ØªØºÙŠØ± Ø§Ø³Ù… Ø±ÙˆÙ… Ø§Ù„ÙÙˆÙŠØ³ Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†
    );
  }
  if (vojson[oldMember.guild.id].stats === "disable") {
    return;
  }
});

////ØªØ¹Ø¯ÙŠÙ„ ØºÙŠØ± Ø§Ø³Ø§Ø³ÙŠ

client.on("message", message => {
    if(enabled){
  if (message.content.startsWith(prefix + "ØªÙ‚Ø¯ÙŠÙ…")) {
    if (!message.channel.guild) return;
    if (message.author.bot) return;
    let channel = message.guild.channels.find(gg => gg.name === "logs-tkdim");
  //  if (!channel)
    if (channel) {
      message.channel.send(message.member + ", **:timer:**").then(m => {
        m.edit(message.member + ", **Ø§Ø³Ù…Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚Ù‰  âœ**");
        m.channel
          .awaitMessages(m1 => m1.author == message.author, {
            maxMatches: 1,
            time: 60 * 1000
          })
          .then(m1 => {
            m1 = m1.first();
            var name = m1.content;
            m1.delete();
            m.edit(message.member + ", **:timer:**").then(m => {
              m.edit(message.member + ", **ÙƒÙ… Ø¹Ù…Ø±Ùƒ ğŸ“**");
              setTimeout(() => {
                m.delete();
              }, 10000);
              m.channel
                .awaitMessages(m2 => m2.author == message.author, {
                  maxMatches: 1,
                  time: 60 * 1000
                })
                .then(m2 => {
                  m2 = m2.first();
                  var age = m2.content;
                  m2.delete();
                  message.channel
                    .send(message.member + ", **:timer:**")
                    .then(m => {
                      m.edit(message.member + ", **Ù‡Ù„ ØªØªÙØ§Ø¹Ù„ ÙÙŠ Ø§Ù„Ø±ØªØ¨Ù‡ğŸ™**");
                      setTimeout(() => {
                        m.delete();
                      }, 10000);
                      m.channel
                        .awaitMessages(m1 => m1.author == message.author, {
                          maxMatches: 1,
                          time: 60 * 1000
                        })
                        .then(m3 => {
                          m3 = m3.first();
                          var ask = m3.content;
                          m3.delete();
                          message.channel
                            .send(message.member + ", **:timer:**")
                            .then(m => {
                              m.edit(
                                message.member + ", **Ù‡Ù„ Ø³ØªØ­ØªØ±Ù… Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† ØŸ ğŸ“‘**"
                              );
                              setTimeout(() => {
                                m.delete();
                              }, 10000);
                              m.channel
                                .awaitMessages(
                                  m1 => m1.author == message.author,
                                  { maxMatches: 1, time: 60 * 1000 }
                                )
                                .then(m4 => {
                                  m4 = m4.first();
                                  var ask2 = m4.content;
                                  m4.delete();
                                  message.channel
                                    .send(message.member + ", **:timer:**")
                                    .then(m => {
                                      m.edit(
                                        message.member +
                                          ", **Ù„Ù…Ø§Ø°Ø§ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙ†Ø§ Ø§Ù† Ù†Ù‚Ø¨Ù„Ùƒ ØŸ ÙˆÙ…Ø§ Ù‡ÙŠ Ø§Ù„Ø±ØªØ¨Ù‡ Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯Ù‡Ø§ ğŸ¤”**"
                                      );
                                      m.channel
                                        .awaitMessages(
                                          m1 => m1.author == message.author,
                                          { maxMatches: 1, time: 60 * 1000 }
                                        )
                                        .then(m5 => {
                                          m5 = m5.first();
                                          var ask3 = m5.content;
                                          m5.delete();
                                          m.edit(
                                            message.member +
                                              ", **....Ø¬Ø§Ø±Ù‰ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª**"
                                          ).then(mtime => {
                                            setTimeout(() => {
                                              let embed = new Discord.RichEmbed()
                                                .setColor("RANDOM")
                                                .setTitle(
                                                  `**ØªÙ‚Ø¯ÙŠÙ… Ø¹Ù„Ù‰ Ø±ØªØ¨Ù‡** [__**${message.guild.name}**__]`
                                                )
                                                .addField(
                                                  "**`Ø§Ø³Ù…Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„`**",
                                                  `${name}`,
                                                  true
                                                )
                                                .addField(
                                                  "**`Ø§Ù„Ø¹Ù…Ø±`**",
                                                  `${age}`,
                                                  true
                                                )
                                                .addField(
                                                  "**`Ù‡Ù„ Ø³ÙˆÙ ÙŠØªÙØ§Ø¹Ù„ ØŸ`**",
                                                  `${ask}`
                                                )
                                                .addField(
                                                  "**`ÙƒÙ… Ù…Ø¯Ù‡ ØªÙˆØ§Ø¬Ø¯Ùƒ ÙÙŠ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯ ÙÙŠ Ø§Ù„ÙŠÙˆÙ… ØŸ`**",
                                                  `${ask2}`
                                                )
                                                .addField(
                                                  "**`Ø§ÙŠØ´ Ø§Ù„Ø±ØªØ¨Ù‡ ØªØ¨ØºØ§Ù‡ | ÙˆØ´ Ø§Ù„ÙŠ ÙŠÙ…ÙŠØ²Ùƒ Ø¹Ù† ØºÙŠØ±ÙƒØŸ`**",
                                                  `${ask3}`
                                                )
                                                .setFooter(
                                                  `Name : ${message.author.username}\nID User : ${message.author.id}`,
                                                  "https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif"
                                                );
                                              channel.send(embed);
                                            }, 2500);
                                            setTimeout(() => {
                                              mtime.delete();
                                            }, 3000);
                                          });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
          });
      });
    }
  }
    }
});

client.on("message", message => {
    if(enabled){
  if (message.content.startsWith(prefix + "room1")) {
    if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply("Ù‡Ù€Ø°Ø§ Ø§Ù„Ø£Ù…Ù€Ù€Ø± Ù…Ø®ØµØµ Ù„Ù„Ø£Ø¯Ø§Ø±Ù‡Ù‡ ÙÙ‚Ø·!"); }
    if (!message.channel.guild) return;
    if (message.author.bot) return;
   // if (!message.member.hasPermission("`MANAGE_CHANNELS"))
     // return message.reply("**ØªØ­ØªØ§Ø¬ Ø§Ù„Ù‰ `MANAGE_CHANNELS`**");
    message.guild.createChannel("Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…Ø§Øª", "text").then(c => {
      c.overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      });
    });
    message.channel.send("**âœ… ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… Ø§Ù„ØªÙ‚Ø¯ÙŠÙ…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­**");
  }
}
});

client.on("message", message => {
  var args = message.content.split(" ").slice(1);
  var msg = message.content.toLowerCase();
  if (!message.guild) return;
  if(enabled){
  if (!msg.startsWith(prefix + "role")) return;
  if (!message.member.hasPermission("MANAGE_ROLES"))
    return message.channel.send(" **Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª :rolling_eyes:**");
  if (msg.toLowerCase().startsWith(prefix + "rerole")) {
    if (!args[0])
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨ Ù…Ù†Ù‡ Ø§Ù„Ø±ØªØ¨Ø©**");
    if (!args[1])
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**");
    var role = msg
      .split(" ")
      .slice(2)
      .join(" ")
      .toLowerCase();
    var role1 = message.guild.roles
      .filter(r => r.name.toLowerCase().indexOf(role) > -1)
      .first();
    if (!role1)
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**");
    if (message.mentions.members.first()) {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          " Ø§Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.mentions.members.first().removeRole(role1);
      return message.reply(
        "**:white_check_mark: [ " +
          role1.name +
          " ] Ø±ØªØ¨Ø© [ " +
          args[0] +
          " ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† **"
      );
    }
    if (args[0].toLowerCase() == "all") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.guild.members.forEach(m => m.removeRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**"
      );
    } else if (args[0].toLowerCase() == "bots") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.guild.members
        .filter(m => m.user.bot)
        .forEach(m => m.removeRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**"
      );
    } else if (args[0].toLowerCase() == "humans") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.guild.members
        .filter(m => !m.user.bot)
        .forEach(m => m.removeRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**"
      );
    }
  } else {
    if (!args[0])
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ø§Ù„Ø±ØªØ¨Ø©**");
    if (!args[1])
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**");
    var role = msg
      .split(" ")
      .slice(2)
      .join(" ")
      .toLowerCase();
    var role1 = message.guild.roles
      .filter(r => r.name.toLowerCase().indexOf(role) > -1)
      .first();
    if (!role1)
      return message.reply("**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**");
    if (message.mentions.members.first()) {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.mentions.members.first().addRole(role1);
      return message.reply(
        "**:white_check_mark: [ " +
          role1.name +
          " ] Ø±ØªØ¨Ø© [ " +
          args[0] +
          " ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ **"
      );
    }
    if (args[0].toLowerCase() == "all") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );
      message.guild.members.forEach(m => m.addRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**"
      );
    } else if (args[0].toLowerCase() == "bots") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.guild.members
        .filter(m => m.user.bot)
        .forEach(m => m.addRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**"
      );
    } else if (args[0].toLowerCase() == "humans") {
      if (role1.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      message.guild.members
        .filter(m => !m.user.bot)
        .forEach(m => m.addRole(role1));
      return message.reply(
        "**:white_check_mark: [ " + role1.name + " ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**"
      );
    }
  }
  }
});

client.on("message", async message => {
  if (!message.guild) return;
  let mention = message.mentions.members.first();
  let role = message.content
    .split(" ")
    .slice(2)
    .join(" ");
  let mySupport = message.guild.roles.find(gg => gg.name === role);
  if(enabled){
  if (message.content.startsWith(prefix + "Ù‚Ø¨ÙˆÙ„")) {
    if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply("Ù‡Ù€Ø°Ø§ Ø§Ù„Ø£Ù…Ù€Ù€Ø± Ù…Ø®ØµØµ Ù„Ù„Ø£Ø¯Ø§Ø±Ù‡Ù‡ ÙÙ‚Ø·!"); }
    let acRoom = message.guild.channels.find(gg => gg.name === "Ø§Ù„Ù‚Ø¨ÙˆÙ„-Ø§Ù„Ø±ÙØ¶");
    if (!acRoom)
      return message.reply(
        `${prefix}room2 Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… **Ø§Ù„Ù‚Ø¨ÙˆÙ„-Ø§Ù„Ø±ÙØ¶** Ø§Ùˆ Ø§ÙƒØªØ¨ Ø§Ù„Ø§Ù…Ø±`
      );
    if (acRoom) {
      if (!message.guild.member(message.author).hasPermission("ADMINISTRATOR"))
        return;
      if (!mention) return message.reply("Ù…Ù†Ø´Ù† Ø´Ø®Øµ");
      if (!role) return message.reply("Ø§Ø¯Ø®Ù„ Ø§Ø³Ù… Ø±ØªØ¨Ø©");
      if (!mySupport) return message.reply("Ù‡Ø°Ù‡ Ø§Ù„Ø±ØªØ¨Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
      if (mention.roles.has(mySupport))
        return message.reply("Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ Ù…Ø¹Ù‡ Ø§Ù„Ø±ØªØ¨Ø© Ù…Ø³Ø¨Ù‚Ø§");
      if (mySupport.position >= message.member.highestRole.position)
        return message.channel.send(
          "Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ© :rolling_eyes:"
        );

      mention.addRole(mySupport).then(() => {
        acRoom.send(
          `**[ ${mySupport} ] ÙˆØ§Ø¹Ø·Ø§Ø¦Ùƒ Ø±ØªØ¨Ø© ${mention} ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ Ø¨Ù†Ø¬Ø§Ø­**`
        );
      });
    }
  }
  }
});

client.on("message", async message => {
  if(enabled){
  if (message.content.startsWith(prefix + "Ø±ÙØ¶")) {
    if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply("Ù‡Ù€Ø°Ø§ Ø§Ù„Ø£Ù…Ù€Ù€Ø± Ù…Ø®ØµØµ Ù„Ù„Ø£Ø¯Ø§Ø±Ù‡Ù‡ ÙÙ‚Ø·!"); }
    if (!message.channel.guild) return;

    let mention = message.mentions.members.first();
    let acRoom = message.guild.channels.find("name", "Ø§Ù„Ù‚Ø¨ÙˆÙ„-Ø§Ù„Ø±ÙØ¶");
    let rrrr = message.content.split(/ +/).slice(2);
    let reason = rrrr.join(" ");
    if (!acRoom)
      return message.reply(
        `${prefix}room2 Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… **Ø§Ù„Ù‚Ø¨ÙˆÙ„-Ø§Ù„Ø±ÙØ¶** Ø§Ùˆ Ø§ÙƒØªØ¨ Ø§Ù„Ø§Ù…Ø±`
      );
    if (!message.guild.member(message.author).hasPermission("ADMINISTRATOR"))
      return;
    if (!mention) return message.reply("Ù…Ù†Ø´Ù† Ø´Ø®Øµ");
    message.react("âœ…");
    acRoom
      .send(
        `**${mention} ØªÙ… Ø±ÙØ¶Ùƒ Ù„Ù„Ø£Ø³Ù **
Ø§Ù„Ø³Ø¨Ø¨ : \`${reason}\``
      )
      .then(m => m.react("âœ…"));
  }
  }
});
client.on("message", message => {
  if(enabled){
  if (message.content.startsWith(prefix + "room2")) {
    if (!message.guild.member(message.author).hasPermission('ADMINISTRATOR')) { return message.reply("Ù‡Ù€Ø°Ø§ Ø§Ù„Ø£Ù…Ù€Ù€Ø± Ù…Ø®ØµØµ Ù„Ù„Ø£Ø¯Ø§Ø±Ù‡Ù‡ ÙÙ‚Ø·!"); }
    if (!message.channel.guild) return;
    if (message.author.bot) return;
    if (!message.member.hasPermission("MANAGE_CHANNELS"))
      return message.reply("**ØªØ­ØªØ§Ø¬ Ø§Ù„Ù‰ `MANAGE_CHANNELS`**");
    message.guild.createChannel("Ø§Ù„Ù‚Ø¨ÙˆÙ„-Ø§Ù„Ø±ÙØ¶", "text").then(c => {
      c.overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      });
    });
    message.channel.send("**âœ… ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… Ø§Ù„Ù‚Ø¨ÙˆÙ„ ÙˆØ§Ù„Ø±ÙØ¶ Ø¨Ù†Ø¬Ø§Ø­**");
  }
//}
  }
});
client.on("message", async msg => {
    if (message.channel.id === '718209175783735378') {
  if (msg.author.bot) return undefined;
  if (!msg.content.startsWith(prefix)) return undefined;

  let args = msg.content.split(" ");

  let command = msg.content.toLowerCase().split(" ")[0];
  command = command.slice(prefix.length);

  if (command === `avatar`) {
    if (msg.channel.type === "dm")
      return msg.channel.send(
        "Nope Nope!! u can't use avatar command in DMs (:"
      );
    let mentions = msg.mentions.members.first();
    if (!mentions) {
      let sicon = msg.author.avatarURL;
      let embed = new Discord.RichEmbed()
        .setImage(msg.author.avatarURL)
        .setColor("#5074b3");
      msg.channel.send({ embed });
    } else {
      let sicon = mentions.user.avatarURL;
      let embed = new Discord.RichEmbed().setColor("#5074b3").setImage(sicon);
      msg.channel.send({ embed });
    }
	}
  }
});
